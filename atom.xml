<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WANGCAN&#39;S BLOG</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-21T10:26:28.476Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WANGCAN</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CGI，FastCGI，PHP-CGI与PHP-FPM，php运行模式</title>
    <link href="http://yoursite.com/2016/11/21/php-fpm/"/>
    <id>http://yoursite.com/2016/11/21/php-fpm/</id>
    <published>2016-11-21T02:53:51.000Z</published>
    <updated>2016-11-21T10:26:28.476Z</updated>
    
    <content type="html">&lt;p&gt;  概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;CGI&quot;&gt;&lt;a href=&quot;#CGI&quot; class=&quot;headerlink&quot; title=&quot;CGI&quot;&gt;&lt;/a&gt;CGI&lt;/h2&gt;&lt;p&gt;CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。&lt;br&gt;CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。&lt;/p&gt;
&lt;h2 id=&quot;FastCGI&quot;&gt;&lt;a href=&quot;#FastCGI&quot; class=&quot;headerlink&quot; title=&quot;FastCGI&quot;&gt;&lt;/a&gt;FastCGI&lt;/h2&gt;&lt;p&gt;FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次（这是CGI最为人诟病的fork-and-execute 模式）。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。&lt;/p&gt;
&lt;p&gt;FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。&lt;/p&gt;
&lt;h5 id=&quot;FastCGI特点&quot;&gt;&lt;a href=&quot;#FastCGI特点&quot; class=&quot;headerlink&quot; title=&quot;FastCGI特点&quot;&gt;&lt;/a&gt;FastCGI特点&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;FastCGI具有语言无关性&lt;/li&gt;
&lt;li&gt;FastCGI在进程中的应用程序，独立于核心web服务器运行，提供了一个比API更安全的环境。APIs把应用程序的代码与核心的web服务器链接在一起，这意味着在一个错误的API的应用程序可能会损坏其他应用程序或核心服务器。 恶意的API的应用程序代码甚至可以窃取另一个应用程序或核心服务器的密钥。&lt;/li&gt;
&lt;li&gt;当客户端请求到达web server时,fastcgi进程管理器选择并连接到一个CGI解析器，Web server将CGI环境变量和标准输入发送到fastcgi的php-cgi子进程中&lt;/li&gt;
&lt;li&gt;FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述情况中，你可以想象CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。&lt;/p&gt;
&lt;h5 id=&quot;FastCGI的不足&quot;&gt;&lt;a href=&quot;#FastCGI的不足&quot; class=&quot;headerlink&quot; title=&quot;FastCGI的不足&quot;&gt;&lt;/a&gt;FastCGI的不足&lt;/h5&gt;&lt;p&gt;因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。&lt;/p&gt;
&lt;p&gt;Nginx 0.8.46+PHP 5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M&lt;em&gt;10=150M），开启的64个php-cgi进程消耗1280M内存（20M&lt;/em&gt;64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。&lt;br&gt;上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版)&lt;/p&gt;
&lt;h2 id=&quot;PHP-CGI&quot;&gt;&lt;a href=&quot;#PHP-CGI&quot; class=&quot;headerlink&quot; title=&quot;PHP-CGI&quot;&gt;&lt;/a&gt;PHP-CGI&lt;/h2&gt;&lt;p&gt;PHP-CGI是PHP自带的FastCGI管理器。&lt;/p&gt;
&lt;h6 id=&quot;PHP-CGI的不足：&quot;&gt;&lt;a href=&quot;#PHP-CGI的不足：&quot; class=&quot;headerlink&quot; title=&quot;PHP-CGI的不足：&quot;&gt;&lt;/a&gt;PHP-CGI的不足：&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启。&lt;/li&gt;
&lt;li&gt;直接杀死php-cgi进程，php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;PHP-FPM&quot;&gt;&lt;a href=&quot;#PHP-FPM&quot; class=&quot;headerlink&quot; title=&quot;PHP-FPM&quot;&gt;&lt;/a&gt;PHP-FPM&lt;/h2&gt;&lt;p&gt;PHP-FPM是一个PHP FastCGI管理器，是只用于PHP的，可以在 &lt;a href=&quot;http://php-fpm.org/download下载得到。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://php-fpm.org/download下载得到。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。&lt;/p&gt;
&lt;p&gt;现在我们可以在最新的PHP 5.3.2的源码树里下载得到直接整合了PHP-FPM的分支，据说下个版本会融合进PHP的主分支去。相对Spawn-FCGI，PHP-FPM在CPU和内存方面的控制都更胜一筹，而且前者很容易崩溃，必须用crontab进行监控，而PHP-FPM则没有这种烦恼。&lt;/p&gt;
&lt;p&gt;PHP5.3.3已经集成php-fpm了，不再是第三方的包了。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多有点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。&lt;/p&gt;
&lt;h2 id=&quot;Spawn-FCGI&quot;&gt;&lt;a href=&quot;#Spawn-FCGI&quot; class=&quot;headerlink&quot; title=&quot;Spawn-FCGI&quot;&gt;&lt;/a&gt;Spawn-FCGI&lt;/h2&gt;&lt;p&gt;Spawn-FCGI是一个通用的FastCGI管理服务器，它是lighttpd中的一部份，很多人都用Lighttpd的Spawn-FCGI进行FastCGI模式下的管理工作，不过有不少缺点。而PHP-FPM的出现多少缓解了一些问题，但PHP-FPM有个缺点就是要重新编译，这对于一些已经运行的环境可能有不小的风险(refer)，在php 5.3.3中可以直接使用PHP-FPM了。&lt;/p&gt;
&lt;p&gt;Spawn-FCGI目前已经独成为一个项目，更加稳定一些，也给很多Web 站点的配置带来便利。已经有不少站点将它与nginx搭配来解决动态网页。&lt;/p&gt;
&lt;p&gt;最新的lighttpd也没有包含这一块了(&lt;a href=&quot;http://www.lighttpd.net/search?q=Spawn-FCGI)，但可以在以前版本中找到它。在lighttpd-1.4.15版本中就包含了(http://www.lighttpd.net/download/lighttpd-1.4.15.tar.gz)，目前Spawn-FCGI的下载地址是http://redmine.lighttpd.net/projects/spawn-fcgi，最新版本是http://www.lighttpd.net/download/spawn-fcgi-1.6.3.tar.gz。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.lighttpd.net/search?q=Spawn-FCGI)，但可以在以前版本中找到它。在lighttpd-1.4.15版本中就包含了(http://www.lighttpd.net/download/lighttpd-1.4.15.tar.gz)，目前Spawn-FCGI的下载地址是http://redmine.lighttpd.net/projects/spawn-fcgi，最新版本是http://www.lighttpd.net/download/spawn-fcgi-1.6.3.tar.gz。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：最新的Spawn-FCGI可以到lighttpd.net网站搜索“Spawn-FCGI”找到它的最新版本发布地址。&lt;/p&gt;
&lt;h2 id=&quot;PHP-FPM与spawn-CGI对比&quot;&gt;&lt;a href=&quot;#PHP-FPM与spawn-CGI对比&quot; class=&quot;headerlink&quot; title=&quot;PHP-FPM与spawn-CGI对比&quot;&gt;&lt;/a&gt;PHP-FPM与spawn-CGI对比&lt;/h2&gt;&lt;p&gt;PHP-FPM的使用非常方便，配置都是在PHP-FPM.ini的文件内，而启动、重启都可以从php/sbin/PHP-FPM中进行。更方便的是修改php.ini后可以直接使用PHP-FPM reload进行加载，无需杀掉进程就可以完成php.ini的修改加载&lt;/p&gt;
&lt;p&gt;结果显示使用PHP-FPM可以使php有不小的性能提升。PHP-FPM控制的进程cpu回收的速度比较慢,内存分配的很均匀。&lt;/p&gt;
&lt;p&gt;Spawn-FCGI控制的进程CPU下降的很快，而内存分配的比较不均匀。有很多进程似乎未分配到，而另外一些却占用很高。可能是由于进程任务分配的不均匀导致的。而这也导致了总体响应速度的下降。而PHP-FPM合理的分配，导致总体响应的提到以及任务的平均。&lt;/p&gt;
&lt;h2 id=&quot;nginx处理一个php请求&quot;&gt;&lt;a href=&quot;#nginx处理一个php请求&quot; class=&quot;headerlink&quot; title=&quot;nginx处理一个php请求&quot;&gt;&lt;/a&gt;nginx处理一个php请求&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;nginx服务器启动时自动载入fastcgi进程管理器&lt;/li&gt;
&lt;li&gt;Fastcgi进程管理器(php-fpm)自身初始化,并且启动多个cgi解释进程(php-cgi)并等待来自nginx的连接&lt;/li&gt;
&lt;li&gt;当nginx服务器收到需要解析php的时，将请求转发到fastcgi接口(socket)，fastcgi进程管理器收到请求后选择并连接一个cgi解释器,nginx服务器将cgi环境变量和标准输入发送给cgi解释器(也就是php-cgi)&lt;/li&gt;
&lt;li&gt;FastCGI 子进程(php-cgi)完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时， 请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;PHP运行模式&quot;&gt;&lt;a href=&quot;#PHP运行模式&quot; class=&quot;headerlink&quot; title=&quot;PHP运行模式&quot;&gt;&lt;/a&gt;PHP运行模式&lt;/h2&gt;&lt;h5 id=&quot;cgi&quot;&gt;&lt;a href=&quot;#cgi&quot; class=&quot;headerlink&quot; title=&quot;cgi&quot;&gt;&lt;/a&gt;cgi&lt;/h5&gt;&lt;p&gt;CGI即通用网关接口(Common Gateway Interface)，它是一段程序, 通俗的讲CGI就象是一座桥，把网页和WEB服务器中的执行程序连接起来，&lt;br&gt;它把HTML接收的指令传递给服务器的执行程序，再把服务器执行程序的结果返还给HTML页。&lt;/p&gt;
&lt;p&gt;CGI 的跨平台性能极佳，几乎可以在任何操作系统上实现。&lt;/p&gt;
&lt;p&gt;每有一个用户请求，都会激活一个CGI进程，当用户请求数量非常多时，会大量挤占系统的资源如内存，CPU时间等，造成效能低下。&lt;/p&gt;
&lt;h5 id=&quot;Isapi&quot;&gt;&lt;a href=&quot;#Isapi&quot; class=&quot;headerlink&quot; title=&quot;Isapi&quot;&gt;&lt;/a&gt;Isapi&lt;/h5&gt;&lt;p&gt;ISAPI即Internet Server Application Program Interface，是微软提供的一套面向Internet服务的API接口&lt;/p&gt;
&lt;p&gt;一个ISAPI的DLL，可以在被用户请求激活后长驻内存，等待用户的另一个请求，还可以在一个DLL里设置多个用户请求处理函数，此外，&lt;br&gt;ISAPI的DLL应用程序和WWW服务器处于同一个进程中，效率要显著高于CGI。（由于微软的排他性，只能运行于windows环境)&lt;/p&gt;
&lt;h5 id=&quot;fast-cgi&quot;&gt;&lt;a href=&quot;#fast-cgi&quot; class=&quot;headerlink&quot; title=&quot;fast-cgi&quot;&gt;&lt;/a&gt;fast-cgi&lt;/h5&gt;&lt;p&gt;fast-cgi 是cgi的升级版本，FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次 (这是 CGI 最为人诟病的 fork-and-execute 模式)。&lt;/p&gt;
&lt;h5 id=&quot;cli&quot;&gt;&lt;a href=&quot;#cli&quot; class=&quot;headerlink&quot; title=&quot;cli&quot;&gt;&lt;/a&gt;cli&lt;/h5&gt;&lt;p&gt;cli是php的命令行运行模式，大家经常会使用它，但是可能并没有注意到（例如：我们在Linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式；&lt;/p&gt;
&lt;h5 id=&quot;apache模块的DLL&quot;&gt;&lt;a href=&quot;#apache模块的DLL&quot; class=&quot;headerlink&quot; title=&quot;apache模块的DLL&quot;&gt;&lt;/a&gt;apache模块的DLL&lt;/h5&gt;&lt;p&gt;该运行模式是我们以前在windows环境下使用apache服务器经常使用的，而在模块化(DLL)中，PHP是与Web服务器一起启动并运行的。（是apache在CGI的基础上进行的一种扩展，加快PHP的运行效率）&lt;/p&gt;
&lt;p&gt;参考地址1：&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1319&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1319&lt;/a&gt;&lt;br&gt;参考地址2：&lt;a href=&quot;http://blog.csdn.net/a451491135/article/details/48442581&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/a451491135/article/details/48442581&lt;/a&gt;&lt;br&gt;参考地址3：&lt;a href=&quot;http://blog.csdn.net/enough_br/article/details/6447011&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/enough_br/article/details/6447011&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  概念了解：CGI，FastCGI，PHP-CGI与PHP-FPM&lt;br&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从</title>
    <link href="http://yoursite.com/2016/08/15/mysql-master-slave-study/"/>
    <id>http://yoursite.com/2016/08/15/mysql-master-slave-study/</id>
    <published>2016-08-15T02:53:51.000Z</published>
    <updated>2016-08-15T09:36:44.540Z</updated>
    
    <content type="html">&lt;p&gt;  简单的实现了主从复制、读写分离、负载均衡&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置主机&quot;&gt;&lt;a href=&quot;#配置主机&quot; class=&quot;headerlink&quot; title=&quot;配置主机&quot;&gt;&lt;/a&gt;配置主机&lt;/h2&gt;&lt;h6 id=&quot;编辑配置文件&quot;&gt;&lt;a href=&quot;#编辑配置文件&quot; class=&quot;headerlink&quot; title=&quot;编辑配置文件&quot;&gt;&lt;/a&gt;编辑配置文件&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;/etc/my.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;开启二进制日志&quot;&gt;&lt;a href=&quot;#开启二进制日志&quot; class=&quot;headerlink&quot; title=&quot;开启二进制日志&quot;&gt;&lt;/a&gt;开启二进制日志&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;log-bin=master-bin
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;指定日志格式&quot;&gt;&lt;a href=&quot;#指定日志格式&quot; class=&quot;headerlink&quot; title=&quot;指定日志格式&quot;&gt;&lt;/a&gt;指定日志格式&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;binlog-format=mixed
server-id=30
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;日志格式mixed表示自动&lt;/p&gt;
&lt;p&gt;row表示行改变即产生日志&lt;/p&gt;
&lt;p&gt;statement表示有语句即产生日志&lt;/p&gt;
&lt;p&gt;注意：配置应写在mysqld下，并且检查是否有重复的server-id&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;配置从机&quot;&gt;&lt;a href=&quot;#配置从机&quot; class=&quot;headerlink&quot; title=&quot;配置从机&quot;&gt;&lt;/a&gt;配置从机&lt;/h2&gt;&lt;h6 id=&quot;编辑配置文件-1&quot;&gt;&lt;a href=&quot;#编辑配置文件-1&quot; class=&quot;headerlink&quot; title=&quot;编辑配置文件&quot;&gt;&lt;/a&gt;编辑配置文件&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;/etc/my.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;中继日志&quot;&gt;&lt;a href=&quot;#中继日志&quot; class=&quot;headerlink&quot; title=&quot;中继日志&quot;&gt;&lt;/a&gt;中继日志&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;relay-log=slave-bin
server-id=31
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;然后分别重启mysql服务：&quot;&gt;&lt;a href=&quot;#然后分别重启mysql服务：&quot; class=&quot;headerlink&quot; title=&quot;然后分别重启mysql服务：&quot;&gt;&lt;/a&gt;然后分别重启mysql服务：&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;service mysqld restart
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;设置账号&quot;&gt;&lt;a href=&quot;#设置账号&quot; class=&quot;headerlink&quot; title=&quot;设置账号&quot;&gt;&lt;/a&gt;设置账号&lt;/h2&gt;&lt;h6 id=&quot;在主机上配置相应的复制账号&quot;&gt;&lt;a href=&quot;#在主机上配置相应的复制账号&quot; class=&quot;headerlink&quot; title=&quot;在主机上配置相应的复制账号&quot;&gt;&lt;/a&gt;在主机上配置相应的复制账号&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;GRANT REPLICATION SLAVE,

REPLICATION CLIENT ON *.*

TO &amp;apos;wc&amp;apos;@&amp;apos;192.168.33.%&amp;apos;

IDENTIFIED BY &amp;apos;wc&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;在从服务器指定要复制的主服务器&quot;&gt;&lt;a href=&quot;#在从服务器指定要复制的主服务器&quot; class=&quot;headerlink&quot; title=&quot;在从服务器指定要复制的主服务器&quot;&gt;&lt;/a&gt;在从服务器指定要复制的主服务器&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;注意： 要在主服务器下执行 show master status&lt;/p&gt;
&lt;p&gt;配置信息:master_log_pos、master_log_file&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;change master to master_host=&amp;apos;192.168.33.11&amp;apos;, master_user=&amp;apos;wc&amp;apos;,master_password=&amp;apos;wc&amp;apos;,master_log_file=&amp;apos;master-bin.000001&amp;apos;,master_log_pos=282;
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;开启服务&quot;&gt;&lt;a href=&quot;#开启服务&quot; class=&quot;headerlink&quot; title=&quot;开启服务&quot;&gt;&lt;/a&gt;开启服务&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;start slave;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意：若开始配置没成功，再次进行配置的时候要重置服务reset slave&lt;/p&gt;
&lt;p&gt;可以一主多从,不可一从多主&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;主从测试&quot;&gt;&lt;a href=&quot;#主从测试&quot; class=&quot;headerlink&quot; title=&quot;主从测试&quot;&gt;&lt;/a&gt;主从测试&lt;/h2&gt;&lt;h5 id=&quot;主服务器执行&quot;&gt;&lt;a href=&quot;#主服务器执行&quot; class=&quot;headerlink&quot; title=&quot;主服务器执行&quot;&gt;&lt;/a&gt;主服务器执行&lt;/h5&gt;&lt;h6 id=&quot;创建库&quot;&gt;&lt;a href=&quot;#创建库&quot; class=&quot;headerlink&quot; title=&quot;创建库&quot;&gt;&lt;/a&gt;创建库&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;create database test1;

use test1;

create table test(id int(3),name varchar(10));

insert into test values(&amp;apos;aa&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;从数据库查看&quot;&gt;&lt;a href=&quot;#从数据库查看&quot; class=&quot;headerlink&quot; title=&quot;从数据库查看&quot;&gt;&lt;/a&gt;从数据库查看&lt;/h5&gt;&lt;h6 id=&quot;查看主库相应操作是否实现&quot;&gt;&lt;a href=&quot;#查看主库相应操作是否实现&quot; class=&quot;headerlink&quot; title=&quot;查看主库相应操作是否实现&quot;&gt;&lt;/a&gt;查看主库相应操作是否实现&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| shop               |
| test               |
| test1              |
+--------------------+
5 rows in set (0.04 sec)

mysql&amp;gt; show tables;
+-----------------+
| Tables_in_test1 |
+-----------------+
| test            |
+-----------------+
1 row in set (0.00 sec)

mysql&amp;gt; select * from test;
+------+------+
| id   | name |
+------+------+
|    1 | aa   |
+------+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;从数据库执行&quot;&gt;&lt;a href=&quot;#从数据库执行&quot; class=&quot;headerlink&quot; title=&quot;从数据库执行&quot;&gt;&lt;/a&gt;从数据库执行&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;insert into test values(2,&amp;apos;bb&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;主服务器查看主服务器中没有实现&quot;&gt;&lt;a href=&quot;#主服务器查看主服务器中没有实现&quot; class=&quot;headerlink&quot; title=&quot;主服务器查看主服务器中没有实现&quot;&gt;&lt;/a&gt;主服务器查看主服务器中没有实现&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from test;
+------+------+
| id   | name |
+------+------+
|    1 | aa   |
+------+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;互为主从&quot;&gt;&lt;a href=&quot;#互为主从&quot; class=&quot;headerlink&quot; title=&quot;互为主从&quot;&gt;&lt;/a&gt;互为主从&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; 在从服务器上设置主服务器设置，在主服务器上设置从服务器设置，即一台服务器既能为主也能为从&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;原从服务器执行&quot;&gt;&lt;a href=&quot;#原从服务器执行&quot; class=&quot;headerlink&quot; title=&quot;原从服务器执行&quot;&gt;&lt;/a&gt;原从服务器执行&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;insert into test values(3,&amp;apos;cc&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;原主服务器查看&quot;&gt;&lt;a href=&quot;#原主服务器查看&quot; class=&quot;headerlink&quot; title=&quot;原主服务器查看&quot;&gt;&lt;/a&gt;原主服务器查看&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from test;
+------+------+
| id   | name |
+------+------+
|    1 | aa   |
|    3 | cc   |
+------+------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;id冲突问题&quot;&gt;&lt;a href=&quot;#id冲突问题&quot; class=&quot;headerlink&quot; title=&quot;id冲突问题&quot;&gt;&lt;/a&gt;id冲突问题&lt;/h3&gt;&lt;p&gt;互为主从的时候id自增长就出现了可能重复的问题，解决办法可以以设置一台服务器为全单数，另一台为全双数&lt;/p&gt;
&lt;h5 id=&quot;分别从本次与全局进行修改-一台服务器：&quot;&gt;&lt;a href=&quot;#分别从本次与全局进行修改-一台服务器：&quot; class=&quot;headerlink&quot; title=&quot;分别从本次与全局进行修改 一台服务器：&quot;&gt;&lt;/a&gt;分别从本次与全局进行修改 一台服务器：&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;set global auto_increment_increment = 2;
set global auto_increment_offset = 1;
set session auto_increment_increment = 2;
set session auto_increment_offset = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;另一台服务器：&quot;&gt;&lt;a href=&quot;#另一台服务器：&quot; class=&quot;headerlink&quot; title=&quot;另一台服务器：&quot;&gt;&lt;/a&gt;另一台服务器：&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;set global auto_increment_increment = 2;
set global auto_increment_offset = 2;
set session auto_increment_increment=2;
set session auto_increment_offset = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意：auto-increment-increment 和　auto-increment-offset　要写到配置文件中，防止下次重启后失效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;错误1：&quot;&gt;&lt;a href=&quot;#错误1：&quot; class=&quot;headerlink&quot; title=&quot;错误1：&quot;&gt;&lt;/a&gt;错误1：&lt;/h3&gt;&lt;p&gt;在slave服务器show slave status:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先检查：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like ‘server_id&amp;apos;;
+—————+——-+
| Variable_name | Value |
+—————+——-+
| server_id | 3 |
+—————+——-+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主从并不一样，排除该问题。&lt;/p&gt;
&lt;p&gt;auto.cnf里面记录了数据库的uuid，每个库的uuid应该是不一样的。&lt;/p&gt;
&lt;p&gt;查找 find / -name ‘auto.cnf’ ，发现 auto.cnf 所在目录/var/lib/mysql/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[auto]
server-uuid=6dcee5be-8cdb-11e2-9408-90e2ba2e2ea6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决办法，按照这个16进制格式，随便改下，重启mysql即可&lt;/p&gt;
&lt;h3 id=&quot;利用mysql-proxy实现负载均衡&quot;&gt;&lt;a href=&quot;#利用mysql-proxy实现负载均衡&quot; class=&quot;headerlink&quot; title=&quot;利用mysql_proxy实现负载均衡&quot;&gt;&lt;/a&gt;利用mysql_proxy实现负载均衡&lt;/h3&gt;&lt;h5 id=&quot;下载安装mysql-proxy&quot;&gt;&lt;a href=&quot;#下载安装mysql-proxy&quot; class=&quot;headerlink&quot; title=&quot;下载安装mysql_proxy&quot;&gt;&lt;/a&gt;下载安装mysql_proxy&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;wget http://ftp.ntu.edu.tw/pub/MySQL/Downloads/MySQL-Proxy/mysql-proxy-0.8.3-linux-glibc2.3-x86-64bit.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;查看帮助&quot;&gt;&lt;a href=&quot;#查看帮助&quot; class=&quot;headerlink&quot; title=&quot;查看帮助&quot;&gt;&lt;/a&gt;查看帮助&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;./bin/mysql-proxy --help-all
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意两点:&lt;/p&gt;
&lt;p&gt;1.proxy在哪个端口运行&lt;/p&gt;
&lt;p&gt;2.代理的是那几台服务器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;指定代理代理的服务器&quot;&gt;&lt;a href=&quot;#指定代理代理的服务器&quot; class=&quot;headerlink&quot; title=&quot;指定代理代理的服务器&quot;&gt;&lt;/a&gt;指定代理代理的服务器&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;./bin/mysql-proxy \
--proxy-backend-addresses=192.168.31.165:3306 \
--proxy-backend-addresses=192.168.31.145:3306
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;读写分离操作&quot;&gt;&lt;a href=&quot;#读写分离操作&quot; class=&quot;headerlink&quot; title=&quot;读写分离操作&quot;&gt;&lt;/a&gt;读写分离操作&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;./bin/mysql-proxy  \
--proxy-backend-addresses=192.168.31.165:3306 \ #配置写服务器
--proxy-read-only-backend-addresses=192.168.31.145:3306 \ #配置读服务器
--proxy-lua-script=mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua #利用这个脚本
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;简写&quot;&gt;&lt;a href=&quot;#简写&quot; class=&quot;headerlink&quot; title=&quot;简写&quot;&gt;&lt;/a&gt;简写&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;./bin/mysql-proxy -b 192.168.31.165:3306 \
-r 192.168.31.145:3306 \
-s /root/mysql-proxy-0.8.3-linux-glibc2.3-x86-64bit/share/doc/mysql-proxy/rw-splitting
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;  简单的实现了主从复制、读写分离、负载均衡&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="myql" scheme="http://yoursite.com/tags/myql/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器常用命令</title>
    <link href="http://yoursite.com/2016/06/20/vim-study/"/>
    <id>http://yoursite.com/2016/06/20/vim-study/</id>
    <published>2016-06-20T02:53:51.000Z</published>
    <updated>2016-06-21T03:06:13.437Z</updated>
    
    <content type="html">&lt;p&gt;  学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。当你走完这篇文章，你会成为一个vim的 superstar，同时要明白vim是需要不断的来练习的&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一级-–-存活&quot;&gt;&lt;a href=&quot;#第一级-–-存活&quot; class=&quot;headerlink&quot; title=&quot;第一级 – 存活&quot;&gt;&lt;/a&gt;第一级 – 存活&lt;/h3&gt;&lt;p&gt;当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启 动Vim后，vim在 Normal 模式下。&lt;/li&gt;
&lt;li&gt;让我们进入 Insert 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）&lt;/li&gt;
&lt;li&gt;此时，你可以输入文本了，就像你用“记事本”一样。&lt;/li&gt;
&lt;li&gt;如果你想返回 Normal 模式，请按 ESC 键。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令，可以让你在 Normal 模式下幸存下来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i → Insert 模式，按 ESC 回到 Normal 模式.
x → 删当前光标所在的一个字符。
:wq → 存盘 + 退出 (:w 存盘, :q 退出)   （陈皓注：:w 后可以跟文件名）
dd → 删除当前行，并把删除的行存到剪贴板里
p → 粘贴剪贴板
推荐:

hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。
:help &amp;lt;command&amp;gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。&lt;/p&gt;
&lt;p&gt;当是，在你进入第二级时，需要再说一下 Normal 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 Ctrl 键，比如：Ctrl-C。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，在VIM的Normal模式下，所有的键就是功能键了。这个你需要知道。&lt;/p&gt;
&lt;p&gt;标记:&lt;/p&gt;
&lt;p&gt;下面的文字中，如果是 Ctrl-λ我会写成 &lt;c-λ&gt;.&lt;br&gt;以 : 开始的命令你需要输入 &lt;enter&gt;回车，例如 — 如果我写成 :q 也就是说你要输入 :q&lt;enter&gt;.&lt;/enter&gt;&lt;/enter&gt;&lt;/c-λ&gt;&lt;/p&gt;
&lt;h3 id=&quot;第二级-–-感觉良好&quot;&gt;&lt;a href=&quot;#第二级-–-感觉良好&quot; class=&quot;headerlink&quot; title=&quot;第二级 – 感觉良好&quot;&gt;&lt;/a&gt;第二级 – 感觉良好&lt;/h3&gt;&lt;p&gt;上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各种插入模式&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;a → 在光标后插入

o → 在当前行后插入一个新行

O → 在当前行前插入一个新行

cw → 替换从光标所在位置后到一个单词结尾的字符
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;简单的移动光标&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;0 → 数字零，到行头
^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）
$ → 到本行行尾
g_ → 到本行最后一个不是blank字符的位置。
/pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;拷贝/粘贴 （陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;P → 粘贴
yy → 拷贝当前行当行于 ddP
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;Undo/Redo&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;u → undo
&amp;lt;C-r&amp;gt; → redo
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;打开/保存/退出/改变文件(Buffer)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;:e &amp;lt;path/to/file&amp;gt; → 打开一个文件
:w → 存盘
:saveas &amp;lt;path/to/file&amp;gt; → 另存为 &amp;lt;path/to/file&amp;gt;
:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)
:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。
:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。&lt;/p&gt;
&lt;h3 id=&quot;第三级-–-更好，更强，更快&quot;&gt;&lt;a href=&quot;#第三级-–-更好，更强，更快&quot; class=&quot;headerlink&quot; title=&quot;第三级 – 更好，更强，更快&quot;&gt;&lt;/a&gt;第三级 – 更好，更强，更快&lt;/h3&gt;&lt;p&gt;先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。&lt;/p&gt;
&lt;h4 id=&quot;更好&quot;&gt;&lt;a href=&quot;#更好&quot; class=&quot;headerlink&quot; title=&quot;更好&quot;&gt;&lt;/a&gt;更好&lt;/h4&gt;&lt;p&gt;下面，让我们看一下vim是怎么重复自己的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;. → (小数点) 可以重复上一次的命令&lt;/li&gt;
&lt;li&gt;N&lt;command&gt; → 重复某个命令N次&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个示例，找开一个文件你可以试试下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2dd → 删除2行
3p → 粘贴文本3次
100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “
. → 重复上一个命令—— 100 “desu “.
3. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;更强&quot;&gt;&lt;a href=&quot;#更强&quot; class=&quot;headerlink&quot; title=&quot;更强&quot;&gt;&lt;/a&gt;更强&lt;/h4&gt;&lt;p&gt;你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）&lt;/li&gt;
&lt;li&gt;gg → 到第一行。（陈皓注：相当于1G，或 :1）&lt;/li&gt;
&lt;li&gt;G → 到最后一行。&lt;/li&gt;
&lt;li&gt;按单词移动：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;w → 到下一个单词的开头。
e → 到下一个单词的结尾。
&amp;gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）

&amp;gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面，让我来说说最强的光标移动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% : 匹配括号移动，包括 (, {, [. （陈皓注：你需要把光标先移到括号上）
* 和 #:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相信我，上面这三个命令对程序员来说是相当强大的。&lt;/p&gt;
&lt;p&gt;你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：&lt;/p&gt;
&lt;p&gt;&lt;start position=&quot;&quot;&gt;&lt;command&gt;&lt;end position=&quot;&quot;&gt;&lt;/end&gt;&lt;/start&gt;&lt;/p&gt;
&lt;p&gt;例如 0y$ 命令意味着：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 → 先到行头
y → 从这里开始拷贝
$ → 拷贝到本行最后一个字符
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。&lt;/p&gt;
&lt;p&gt;你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。&lt;/p&gt;
&lt;p&gt;还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d (删除 )
v (可视化的选择)
gU (变大写)
gu (变小写)
等等
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）&lt;/p&gt;
&lt;h3 id=&quot;第四级-–-Vim-超能力&quot;&gt;&lt;a href=&quot;#第四级-–-Vim-超能力&quot; class=&quot;headerlink&quot; title=&quot;第四级 – Vim 超能力&quot;&gt;&lt;/a&gt;第四级 – Vim 超能力&lt;/h3&gt;&lt;p&gt;你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。&lt;/p&gt;
&lt;h4 id=&quot;在当前行上移动光标-0-f-F-t-T&quot;&gt;&lt;a href=&quot;#在当前行上移动光标-0-f-F-t-T&quot; class=&quot;headerlink&quot; title=&quot;在当前行上移动光标: 0 ^ $ f F t T , ;&quot;&gt;&lt;/a&gt;在当前行上移动光标: 0 ^ $ f F t T , ;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;0 → 到行头
^ → 到本行的第一个非blank字符
$ → 到行尾
g_ → 到本行最后一个不是blank字符的位置。
fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。
t, → 到逗号前的第一个字符。逗号可以变成其它字符。
3fa → 在当前行查找第三个出现的a。
F 和 T → 和 f 和 t 一样，只不过是相反方向。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有一个很有用的命令是 dt” → 删除所有的内容，直到遇到双引号—— “。&lt;/p&gt;
&lt;h4 id=&quot;区域选择-lt-action-gt-a-lt-object-gt-或-lt-action-gt-i-lt-object-gt&quot;&gt;&lt;a href=&quot;#区域选择-lt-action-gt-a-lt-object-gt-或-lt-action-gt-i-lt-object-gt&quot; class=&quot;headerlink&quot; title=&quot;区域选择 &amp;lt; action&amp;gt;a&amp;lt; object&amp;gt; 或 &amp;lt; action&amp;gt;i&amp;lt; object&amp;gt;&quot;&gt;&lt;/a&gt;区域选择 &amp;lt; action&amp;gt;a&amp;lt; object&amp;gt; 或 &amp;lt; action&amp;gt;i&amp;lt; object&amp;gt;&lt;/h4&gt;&lt;p&gt;在visual 模式下，这些命令很强大，其命令格式为&lt;/p&gt;
&lt;p&gt;action a object 和 action i object&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。
object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：&amp;quot;、 &amp;apos;、 )、 }、 ]。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vi&amp;quot; → 会选择 foo.
va&amp;quot; → 会选择 &amp;quot;foo&amp;quot;.
vi) → 会选择 &amp;quot;foo&amp;quot;.
va) → 会选择(&amp;quot;foo&amp;quot;).
v2i) → 会选择 map (+) (&amp;quot;foo&amp;quot;)
v2a) → 会选择 (map (+) (&amp;quot;foo&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;块操作-lt-C-v-gt&quot;&gt;&lt;a href=&quot;#块操作-lt-C-v-gt&quot; class=&quot;headerlink&quot; title=&quot;块操作: &amp;lt; C-v&amp;gt;&quot;&gt;&lt;/a&gt;块操作: &amp;lt; C-v&amp;gt;&lt;/h4&gt;&lt;p&gt;块操作，典型的操作： 0 &lt;c-v&gt; &lt;c-d&gt; I– [ESC]&lt;/c-d&gt;&lt;/c-v&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;^ → 到行头
&amp;lt;C-v&amp;gt; → 开始块操作
&amp;lt;C-d&amp;gt; → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)
I-- [ESC] → I是插入，插入“--”，按ESC键来为每一行生效。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Windows下的vim，你需要使用 &amp;lt; C-q&amp;gt; 而不是 &amp;lt; C-v&amp;gt; ，&amp;lt; C-v&amp;gt; 是拷贝剪贴板。&lt;/p&gt;
&lt;h3 id=&quot;自动提示：-lt-C-n-gt-和-lt-C-p-gt&quot;&gt;&lt;a href=&quot;#自动提示：-lt-C-n-gt-和-lt-C-p-gt&quot; class=&quot;headerlink&quot; title=&quot;自动提示： &amp;lt; C-n&amp;gt; 和 &amp;lt; C-p&amp;gt;&quot;&gt;&lt;/a&gt;自动提示： &amp;lt; C-n&amp;gt; 和 &amp;lt; C-p&amp;gt;&lt;/h3&gt;&lt;p&gt;在 Insert 模式下，你可以输入一个词的开头，然后按 &lt;c-p&gt;或是&lt;c-n&gt;，自动补齐功能就出现了……&lt;/c-n&gt;&lt;/c-p&gt;&lt;/p&gt;
&lt;h4 id=&quot;宏录制：-qa-操作序列-q-a&quot;&gt;&lt;a href=&quot;#宏录制：-qa-操作序列-q-a&quot; class=&quot;headerlink&quot; title=&quot;宏录制： qa 操作序列 q, @a, @@&quot;&gt;&lt;/a&gt;宏录制： qa 操作序列 q, @a, @@&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;qa 把你的操作记录在寄存器 a。&lt;/li&gt;
&lt;li&gt;于是 @a 会replay被录制的宏。&lt;/li&gt;
&lt;li&gt;@@ 是一个快捷键用来replay最新录制的宏&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;在一个只有一行且这一行只有“1”的文本中，键入如下命令：

qaYp&amp;lt;C-a&amp;gt;q→
qa 开始录制
Yp 复制行.
&amp;lt;C-a&amp;gt; 增加1.
q 停止录制.
@a → 在1下面写下 2
@@ → 在2 正面写下3
现在做 100@@ 会创建新的100行，并把数据增加到 103.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;可视化选择：-v-V&quot;&gt;&lt;a href=&quot;#可视化选择：-v-V&quot; class=&quot;headerlink&quot; title=&quot;可视化选择： v,V,&quot;&gt;&lt;/a&gt;可视化选择： v,V,&lt;c-v&gt;&lt;/c-v&gt;&lt;/h4&gt;&lt;p&gt;前面，我们看到了 &lt;c-v&gt;的示例 （在Windows下应该是&lt;c-q&gt;），我们可以使用 v 和 V。一但被选好了，你可以做下面的事：&lt;/c-q&gt;&lt;/c-v&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;J → 把所有的行连接起来（变成一行）
&amp;lt; 或 &amp;gt; → 左右缩进
= → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在所有被选择的行后加上点东西：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;C-v&amp;gt;
选中相关的行 (可使用 j 或 &amp;lt;C-d&amp;gt; 或是 /pattern 或是 % 等……)
$ 到行最后
A, 输入字符串，按 ESC。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;分屏-split-和-vsplit&quot;&gt;&lt;a href=&quot;#分屏-split-和-vsplit&quot; class=&quot;headerlink&quot; title=&quot;分屏: :split 和 vsplit.&quot;&gt;&lt;/a&gt;分屏: :split 和 vsplit.&lt;/h4&gt;&lt;p&gt;下面是主要的命令，你可以使用VIM的帮助 :help split. 你可以参考本站以前的一篇文章VIM分屏。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:split → 创建分屏 (:vsplit创建垂直分屏)
&amp;lt;C-w&amp;gt;&amp;lt;dir&amp;gt; : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。
&amp;lt;C-w&amp;gt;_ (或 &amp;lt;C-w&amp;gt;|) : 最大化尺寸 (&amp;lt;C-w&amp;gt;| 垂直分屏)
&amp;lt;C-w&amp;gt;+ (或 &amp;lt;C-w&amp;gt;-) : 增加尺寸
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;结束语&quot;&gt;&lt;a href=&quot;#结束语&quot; class=&quot;headerlink&quot; title=&quot;结束语&quot;&gt;&lt;/a&gt;结束语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;上面是作者最常用的90%的命令。&lt;/li&gt;
&lt;li&gt;我建议你每天都学1到2个新的命令。&lt;/li&gt;
&lt;li&gt;在两到三周后，你会感到vim的强大的。&lt;/li&gt;
&lt;li&gt;有时候，学习VIM就像是在死背一些东西。&lt;/li&gt;
&lt;li&gt;幸运的是，vim有很多很不错的工具和优秀的文档。&lt;/li&gt;
&lt;li&gt;运行vimtutor直到你熟悉了那些基本命令。&lt;/li&gt;
&lt;li&gt;其在线帮助文档中你应该要仔细阅读的是 :help usr_02.txt.&lt;/li&gt;
&lt;li&gt;你会学习到诸如  !， 目录，寄存器，插件等很多其它的功能。&lt;br&gt;学习vim就像学弹钢琴一样，一旦学会，受益无穷。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;参考文献：http-coolshell-cn-articles-5426-html&quot;&gt;&lt;a href=&quot;#参考文献：http-coolshell-cn-articles-5426-html&quot; class=&quot;headerlink&quot; title=&quot;参考文献：http://coolshell.cn/articles/5426.html&quot;&gt;&lt;/a&gt;参考文献：&lt;a href=&quot;http://coolshell.cn/articles/5426.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://coolshell.cn/articles/5426.html&lt;/a&gt;&lt;/h5&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;  学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。当你走完这篇文章，你会成为一个vim的 superstar，同时要明白vim是需要不断的来练习的&lt;br&gt;
    
    </summary>
    
      <category term="vim" scheme="http://yoursite.com/categories/vim/"/>
    
    
      <category term="makdown" scheme="http://yoursite.com/tags/makdown/"/>
    
  </entry>
  
  <entry>
    <title>nginx简单配置管理（5）</title>
    <link href="http://yoursite.com/2016/05/11/nginx-staudy-5/"/>
    <id>http://yoursite.com/2016/05/11/nginx-staudy-5/</id>
    <published>2016-05-11T02:53:51.000Z</published>
    <updated>2016-05-11T15:33:49.815Z</updated>
    
    <content type="html">&lt;p&gt;nginx反向代理服务器+负载均衡，memcached，nginx+php+memcache的扩展，&lt;br&gt;第3方模块编译及一致性哈希应用,大访问量优化整体思路&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、-nginx反向代理服务器-负载均衡&quot;&gt;&lt;a href=&quot;#一、-nginx反向代理服务器-负载均衡&quot; class=&quot;headerlink&quot; title=&quot;一、 nginx反向代理服务器+负载均衡&quot;&gt;&lt;/a&gt;一、 nginx反向代理服务器+负载均衡&lt;/h2&gt;&lt;h4 id=&quot;1-新建一个nginx虚拟机&quot;&gt;&lt;a href=&quot;#1-新建一个nginx虚拟机&quot; class=&quot;headerlink&quot; title=&quot;1. 新建一个nginx虚拟机&quot;&gt;&lt;/a&gt;1. 新建一个nginx虚拟机&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;我是利用vagrant新建的一个环境&lt;/p&gt;
&lt;h4 id=&quot;2-把原来的配置加上一句命令&quot;&gt;&lt;a href=&quot;#2-把原来的配置加上一句命令&quot; class=&quot;headerlink&quot; title=&quot;2. 把原来的配置加上一句命令&quot;&gt;&lt;/a&gt;2. 把原来的配置加上一句命令&lt;/h4&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;proxy_pass http://192.168.33.13:80;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;（关闭其他php配置项）这样就被代理到192.168.33.13上了；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location ~ \.php$ {
  proxy_pass http://192.168.33.13:80;
 #root html;
 #fastcgi_pass   127.0.0.1:9000;
 #fastcgi_index  index.php;
 #fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
 #include        fastcgi_params;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;/p&gt;
&lt;h4 id=&quot;3-负载均衡&quot;&gt;&lt;a href=&quot;#3-负载均衡&quot; class=&quot;headerlink&quot; title=&quot;3. 负载均衡&quot;&gt;&lt;/a&gt;3. 负载均衡&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;反向代理后端如果有多台服务器,自然可形成负载均衡,但proxy_pass如何指向多台服务器?&lt;br&gt;把多台服务器用 upstream指定绑定在一起并起个组名,然后proxy_pass指向该组&lt;br&gt;默认的均衡的算法很简单,就是针对后端服务器的顺序,逐个请求.&lt;/p&gt;
&lt;h4 id=&quot;4-反向代理导致了后端服务器的IP-为前端服务器的IP-而不是客户真正的IP&quot;&gt;&lt;a href=&quot;#4-反向代理导致了后端服务器的IP-为前端服务器的IP-而不是客户真正的IP&quot; class=&quot;headerlink&quot; title=&quot;4. 反向代理导致了后端服务器的IP,为前端服务器的IP,而不是客户真正的IP&quot;&gt;&lt;/a&gt;4. 反向代理导致了后端服务器的IP,为前端服务器的IP,而不是客户真正的IP&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;可以在配置时设置真实ip:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxy_set_header X-Forwarded-For $remote_addr;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;二、memcached&quot;&gt;&lt;a href=&quot;#二、memcached&quot; class=&quot;headerlink&quot; title=&quot;二、memcached&quot;&gt;&lt;/a&gt;二、memcached&lt;/h2&gt;&lt;h4 id=&quot;1-memcached&quot;&gt;&lt;a href=&quot;#1-memcached&quot; class=&quot;headerlink&quot; title=&quot;1. memcached&quot;&gt;&lt;/a&gt;1. memcached&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;Memcache是一种内存缓存，把经常存取的对象或数据缓存在内存中，内存中缓存的这些数据通过API的方式被存取，&lt;br&gt;数据就像一张大的HASH表，以key-value对的方式存在&lt;/p&gt;
&lt;h4 id=&quot;2-memcached的编译与安装&quot;&gt;&lt;a href=&quot;#2-memcached的编译与安装&quot; class=&quot;headerlink&quot; title=&quot;2. memcached的编译与安装&quot;&gt;&lt;/a&gt;2. memcached的编译与安装&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt; 注意不能直接安装libevent&lt;/p&gt;
&lt;p&gt;这是在编译memcached过程中经常遇到的问题（memcached基于libevent的事件处理机制。libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能封装成统一的接口。即使服务器的连接数增加，也能发挥时间复杂度O(1)的性能。 memcached使用这个libevent库，因此能在Linux、BSD、Solaris等操作系统上发挥其高性能。）。这时就要安装libevent库了。&lt;/p&gt;
&lt;p&gt;在libevent官方网站&lt;a href=&quot;http://libevent.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://libevent.org&lt;/a&gt; 中可以下载到最新最稳定版源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrpkn.com1.z0.glb.clouddn.com/memcache.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下载解压配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/usr
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;a href=&quot;http://blog.csdn.net/chaijunkun/article/details/6993264&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chaijunkun/article/details/6993264&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-安装完成后启动memcached&quot;&gt;&lt;a href=&quot;#3-安装完成后启动memcached&quot; class=&quot;headerlink&quot; title=&quot;3. 安装完成后启动memcached&quot;&gt;&lt;/a&gt;3. 安装完成后启动memcached&lt;/h4&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/memcached/bin/memcached -d -m 128  -u root -p 11211 -c 256 -P /tmp/memcached.pid
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意参数大小写，还有参数是否正确&lt;/p&gt;
&lt;p&gt;启动参数说明：&lt;/p&gt;
&lt;p&gt;  -d 选项是启动一个守护进程，&lt;/p&gt;
&lt;p&gt;  -m 是分配给Memcache使用的内存数量，单位是MB，默认64MB&lt;/p&gt;
&lt;p&gt;  -M return error on memory exhausted (rather than removing items)&lt;/p&gt;
&lt;p&gt;  -u 是运行Memcache的用户，如果当前为root 的话，需要使用此参数指定用户。&lt;/p&gt;
&lt;p&gt;  -l 是监听的服务器IP地址，默认为所有网卡。&lt;/p&gt;
&lt;p&gt;  -p 是设置Memcache的TCP监听的端口，最好是1024以上的端口&lt;/p&gt;
&lt;p&gt;  -c 选项是最大运行的并发连接数，默认是1024&lt;/p&gt;
&lt;p&gt;  -P 是设置保存Memcache的pid文件&lt;/p&gt;
&lt;p&gt;  -f &lt;factor&gt; chunk size growth factor (default: 1.25)&lt;/factor&gt;&lt;/p&gt;
&lt;p&gt;  -I Override the size of each slab page. Adjusts max item size(1.4.2版本新增)&lt;/p&gt;
&lt;p&gt;  也可以启动多个守护进程，但是端口不能重复&lt;/p&gt;
&lt;h4 id=&quot;4-停止Memcache进程：&quot;&gt;&lt;a href=&quot;#4-停止Memcache进程：&quot; class=&quot;headerlink&quot; title=&quot;4. 停止Memcache进程：&quot;&gt;&lt;/a&gt;4. 停止Memcache进程：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;kill `cat /tmp/memcached.pid`
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;三、nginx-php-memcache的扩展&quot;&gt;&lt;a href=&quot;#三、nginx-php-memcache的扩展&quot; class=&quot;headerlink&quot; title=&quot;三、nginx+php+memcache的扩展&quot;&gt;&lt;/a&gt;三、nginx+php+memcache的扩展&lt;/h2&gt;&lt;h4 id=&quot;1-memcache的扩展安装&quot;&gt;&lt;a href=&quot;#1-memcache的扩展安装&quot; class=&quot;headerlink&quot; title=&quot;1. memcache的扩展安装&quot;&gt;&lt;/a&gt;1. memcache的扩展安装&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt; 下载地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://pecl.php.net/package/memcache
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 解压安装编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/httpd/bin/phpize（针对编译的php）
./configure  --with-php-config=/usr/local/httpd/bin/php-config（制定配置位置）
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;复制扩展路径&lt;br&gt;    /usr/local/httpd/lib/php/extensions/no-debug-non-zts-20131226/&lt;/p&gt;
&lt;p&gt;打开php.ini(引入扩展)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extension= /usr/local/httpd/lib/php/extensions/no-debug-non-zts-20131226/memcache.so
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;杀掉php进程，重启php&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkill -9 php
/usr/local/httpd/sbin/php-fpm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启php-fpm详情参考：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.cnblogs.com/zdz8207/p/3765579.html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrpkn.com1.z0.glb.clouddn.com/liucheng.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-连接memcache需要安装telnet&quot;&gt;&lt;a href=&quot;#2-连接memcache需要安装telnet&quot; class=&quot;headerlink&quot; title=&quot;2. 连接memcache需要安装telnet&quot;&gt;&lt;/a&gt;2. 连接memcache需要安装telnet&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt; 查看本机是否安装telnet&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#rpm -qa | grep telnet
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果什么都不显示。说明你没有安装telnet&lt;/p&gt;
&lt;p&gt; 开始安装&lt;br&gt;    yum install xinetd&lt;br&gt;    yum install telnet&lt;br&gt;    yum install telnet-server&lt;/p&gt;
&lt;p&gt;装好telnet服务之后，默认是不开启服务的，下面我们需要修改文件来开启服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/xinetd.d/telnet 修改 disable = yes 为 disable = no
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要激活xinetd服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# service xinetd restart
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#/etc/rc.d/init.d/xinetd restart
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行连接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;telnet 127.0.0.1 11211
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果还是起不来就看看防火墙是否关闭&lt;/p&gt;
&lt;h4 id=&quot;3-测试使用memcache&quot;&gt;&lt;a href=&quot;#3-测试使用memcache&quot; class=&quot;headerlink&quot; title=&quot;3. 测试使用memcache&quot;&gt;&lt;/a&gt;3. 测试使用memcache&lt;/h4&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;location / {
      set $memcached_key &amp;quot;$uri&amp;quot;;# 设置key
      memcached_pass 127.0.0.1:11211;#从memcache读取key
      error_page 404 /callback.php; #要是没找到key就调用callback.php
      #root   html;
      #index index.php  index.html index.htm;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//连接数据库，查询并写入memcached
$conect = mysql_connect(&amp;apos;localhost&amp;apos;,&amp;apos;root&amp;apos;,&amp;apos;&amp;apos;);
$sql = &amp;apos;use test&amp;apos;;
$a =mysql_query($sql,$conect);
//var_dump($a);
$sql = &amp;quot;set names utf8&amp;quot;;
mysql_query($sql,$conect);
$sql = &amp;quot;select * from custom_auth_user where id=&amp;quot;.$uid;
$rs = mysql_query($sql,$conect);
//var_dump($rs);

$user = mysql_fetch_assoc($rs);

if(empty($user)){
        echo &amp;apos;no this user&amp;apos;;
 } else {
        echo &amp;apos;from mysql&amp;apos;;
        $mem = new memcache();
        $mem-&amp;gt;connect(&amp;apos;localhost&amp;apos;,11211);
        $mem-&amp;gt;add($uri,$user,0,300);
        $mem-&amp;gt;close();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;四、第3方模块编译及一致性哈希应用&quot;&gt;&lt;a href=&quot;#四、第3方模块编译及一致性哈希应用&quot; class=&quot;headerlink&quot; title=&quot;四、第3方模块编译及一致性哈希应用&quot;&gt;&lt;/a&gt;四、第3方模块编译及一致性哈希应用&lt;/h2&gt;&lt;h4 id=&quot;1-官网：&quot;&gt;&lt;a href=&quot;#1-官网：&quot; class=&quot;headerlink&quot; title=&quot;1. 官网：&quot;&gt;&lt;/a&gt;1. 官网：&lt;/h4&gt;&lt;p&gt;   &lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/nginx-zh/HttpUpstreamConsistentHash.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tool.oschina.net/uploads/apidocs/nginx-zh/HttpUpstreamConsistentHash.htm&lt;/a&gt;&lt;br&gt;   &lt;a href=&quot;https://www.nginx.com/resources/wiki/modules/consistent_hash/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.nginx.com/resources/wiki/modules/consistent_hash/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-编译第三方模块&quot;&gt;&lt;a href=&quot;#2-编译第三方模块&quot; class=&quot;headerlink&quot; title=&quot;2. 编译第三方模块&quot;&gt;&lt;/a&gt;2. 编译第三方模块&lt;/h4&gt;&lt;p&gt;查看编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -V
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之前的编译加上要增加模块的路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/usr/local/nginx --add- module=/usr/local/src/ngx_http_consistent_hash-master/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为保证不受之前nginx进程的影响，先杀掉nginx进程再编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkill -9 nginx
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;3-配置&quot;&gt;&lt;a href=&quot;#3-配置&quot; class=&quot;headerlink&quot; title=&quot;3. 配置&quot;&gt;&lt;/a&gt;3. 配置&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;upstream somestream {
       consistent_hash $request_uri;(指定算法)
       server 10.50.1.3:11211;
       server 10.50.1.4:11211;
       server 10.50.1.5:11211;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启新的memcache端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/user/local/memcached/bin/memcached -u nobody -vv -p 11212
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时也需要制定同样的算法到存到memcahe&lt;br&gt;保证nginx请求的key和memcache增加的key是一致的&lt;br&gt;memcache的hash策略&lt;br&gt;在PHP.ini中增加如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;memcache.hash_strategy=consistent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;php也增加和nginx一样多的服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mem = new memcache();
$mem-&amp;gt;addServer(&amp;apos;192.168.33.10&amp;apos;,11211);
$mem-&amp;gt;addServer(&amp;apos;192.168.33.10&amp;apos;,11212);
$mem-&amp;gt;addServer(&amp;apos;192.168.33.10&amp;apos;,11213);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;tips&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;upstream做负载均衡时，要用IP或远程主机名，不能用localhost&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认的负载均衡的算法:&lt;/li&gt;
&lt;li&gt;是设置计数器,轮流请求N台服务器.&lt;/li&gt;
&lt;li&gt;可以安装第3方模式,来利用uri做hash等等.&lt;/li&gt;
&lt;li&gt;如&lt;a href=&quot;http://wiki.nginx.org/NginxHttpUpstreamConsistentHash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wiki.nginx.org/NginxHttpUpstreamConsistentHash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;这个模块就是用一致性hash来请求后端结节,并且其算法,与PHP中的memcache模块的一致性hash算法,兼容.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;五、大访问量优化整体思路&quot;&gt;&lt;a href=&quot;#五、大访问量优化整体思路&quot; class=&quot;headerlink&quot; title=&quot;五、大访问量优化整体思路&quot;&gt;&lt;/a&gt;五、大访问量优化整体思路&lt;/h2&gt;&lt;p&gt;对于高性能网站 ,请求量大,如何支撑？&lt;/p&gt;
&lt;h4 id=&quot;1-要减少请求&quot;&gt;&lt;a href=&quot;#1-要减少请求&quot; class=&quot;headerlink&quot; title=&quot;1. 要减少请求&quot;&gt;&lt;/a&gt;1. 要减少请求&lt;/h4&gt;&lt;p&gt;对于开发人员—-合并css, 背景图片, 减少mysql查询等.&lt;/p&gt;
&lt;h4 id=&quot;2-对于运维&quot;&gt;&lt;a href=&quot;#2-对于运维&quot; class=&quot;headerlink&quot; title=&quot;2. 对于运维&quot;&gt;&lt;/a&gt;2. 对于运维&lt;/h4&gt;&lt;p&gt;nginx的expires ,利用浏览器缓存等,减少查询.&lt;/p&gt;
&lt;h4 id=&quot;3-利用cdn来响应请求&quot;&gt;&lt;a href=&quot;#3-利用cdn来响应请求&quot; class=&quot;headerlink&quot; title=&quot;3. 利用cdn来响应请求&quot;&gt;&lt;/a&gt;3. 利用cdn来响应请求&lt;/h4&gt;&lt;h4 id=&quot;4-最终剩下的-不可避免的请求&quot;&gt;&lt;a href=&quot;#4-最终剩下的-不可避免的请求&quot; class=&quot;headerlink&quot; title=&quot;4. 最终剩下的,不可避免的请求&quot;&gt;&lt;/a&gt;4. 最终剩下的,不可避免的请求&lt;/h4&gt;&lt;p&gt;—-服务器集群+负载均衡来支撑.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思考如何更好的响应高并发请求.：&lt;/p&gt;
&lt;p&gt;大的认识——-既然响应是不可避免的,我们要做的是把工作内容”平均”分给每台服务器.&lt;br&gt;最理想的状态 每台服务器的性能都被充分利用.&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;nginx反向代理服务器+负载均衡，memcached，nginx+php+memcache的扩展，&lt;br&gt;第3方模块编译及一致性哈希应用,大访问量优化整体思路&lt;br&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>nginx简单配置管理(4)</title>
    <link href="http://yoursite.com/2016/04/28/nginx-staudy-4/"/>
    <id>http://yoursite.com/2016/04/28/nginx-staudy-4/</id>
    <published>2016-04-28T14:53:51.000Z</published>
    <updated>2016-05-11T16:04:53.148Z</updated>
    
    <content type="html">&lt;p&gt;编译php并与nginx整合,安装ecshop,gzip+nginx压缩提升网速,nginx设置缓存设置&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;编译php并与nginx整合&quot;&gt;&lt;a href=&quot;#编译php并与nginx整合&quot; class=&quot;headerlink&quot; title=&quot;编译php并与nginx整合&quot;&gt;&lt;/a&gt;编译php并与nginx整合&lt;/h2&gt;&lt;h4 id=&quot;1-安装mysql&quot;&gt;&lt;a href=&quot;#1-安装mysql&quot; class=&quot;headerlink&quot; title=&quot;1. 安装mysql&quot;&gt;&lt;/a&gt;1. 安装mysql&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;yum install mysql mysql-devel 客户
yum install mysql-server服务
yum install dg dg-devel
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-安装php&quot;&gt;&lt;a href=&quot;#2-安装php&quot; class=&quot;headerlink&quot; title=&quot;2. 安装php&quot;&gt;&lt;/a&gt;2. 安装php&lt;/h4&gt;&lt;p&gt;安装php需要注意的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果原来与apache编译过的php需要重新编译；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;apache一般是把php当做自己的一个模块来启动的.而nginx则是把http请求变量(如 get,user_agent等)转发给 php进程,即php独立进程,与nginx进行通信. 称为 fastcgi运行方式，是不能用于nginx的.需要进入目录执行make clean重新执行编译。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要考虑需要编译的功能、编译在哪&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持mysql、gd库要支持、字体要支持、以fpm(fascgi)方式运行，那么就有了mysql,gd,ttf,fpm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  不知道怎么添加编译可以查看帮助命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure -help | grep mysql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  字体需要安装freetype：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install freetype
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  那么编译就可以这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/usr/local/php \
--with-mysql=mysqlnd \
--enable-mysqlnd \
--with-gd \
--enable-gd-native-ttf \
--enable-gd-jis-conv
--enable-fpm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 如果编译过程中遇到错误就看看提示，一般都是少编译了什么然后再加上重新编译然后执行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;复制php配置文件,进入到php目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp /usr/local/src/php-5.6.17/php.ini-development ./lib/php.ini
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;复制php进程管理器php-fpm配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp /etc/php-fpm.conf.default etc/php-fpm.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行php_fpm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/sbin/php-fpm
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;3-简单配置&quot;&gt;&lt;a href=&quot;#3-简单配置&quot; class=&quot;headerlink&quot; title=&quot;3. 简单配置&quot;&gt;&lt;/a&gt;3. 简单配置&lt;/h4&gt;&lt;p&gt;记住核心的一句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;发请求信息给php进程默认端口9000，让php进程来处理，&lt;br&gt;指定该目录下的php文件，包含fastccgi_params参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;location ~ \.php$ {
  root html;
  fastcgi_pass 127.0.0.1:9000;
  fastcgi_index index.php;
  fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
  include fastcgi_params;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;区别于apache+php：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/usr/local/php \
--with-mysql=mysqlnd \
--enable-mysqlnd \
--with-gd \
--enable-gd-native-ttf \
--enable-gd-jis-conv
--with-apxs2=/usr/local/httpd/bin/apxs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;遇到问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;configure: error: xml2-config not found. Please check your&amp;amp;nb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决办法参考：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://blog.sina.com.cn/s/blog_7253980a0101gw3n.html
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;安装ecshop&quot;&gt;&lt;a href=&quot;#安装ecshop&quot; class=&quot;headerlink&quot; title=&quot;安装ecshop&quot;&gt;&lt;/a&gt;安装ecshop&lt;/h2&gt;&lt;h4 id=&quot;1-下载ecshop&quot;&gt;&lt;a href=&quot;#1-下载ecshop&quot; class=&quot;headerlink&quot; title=&quot;1. 下载ecshop&quot;&gt;&lt;/a&gt;1. 下载ecshop&lt;/h4&gt;&lt;p&gt;下载ecshop，把upload目录传到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/html/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更改ecshop配置文件：ecshop/includes/init.php&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error_reporting(0);
@ini_set(&amp;apos;display_errors&amp;apos;,        0);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if ((DEBUG_MODE &amp;amp; 1) == 1) {
  error_reporting(E_ALL);
} else {
    error_reporting(E_ALL ^ (E_NOTICE | E_WARNING));
}
if ((DEBUG_MODE &amp;amp; 4) == 4) {
    include(ROOT_PATH . &amp;apos;includes/lib.debug.php&amp;apos;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在ecshop/install/inclodes/init.php中更改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@ini_set(&amp;apos;display_errors&amp;apos;, 0);
error_reporting(0);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有/usr/local/nginx/html/ecshop/admin/includes/init.php中同样也要修改&lt;/p&gt;
&lt;h4 id=&quot;2-配置nginx-conf&quot;&gt;&lt;a href=&quot;#2-配置nginx-conf&quot; class=&quot;headerlink&quot; title=&quot;2. 配置nginx.conf&quot;&gt;&lt;/a&gt;2. 配置nginx.conf&lt;/h4&gt;&lt;p&gt;默认寻找文件index.php&lt;/p&gt;
&lt;h4 id=&quot;3-测试步骤&quot;&gt;&lt;a href=&quot;#3-测试步骤&quot; class=&quot;headerlink&quot; title=&quot;3. 测试步骤&quot;&gt;&lt;/a&gt;3. 测试步骤&lt;/h4&gt;&lt;p&gt;访问ecshop提示安装-》更改权限-》连接数据库&lt;/p&gt;
&lt;h4 id=&quot;4-一般会遇到的问题：&quot;&gt;&lt;a href=&quot;#4-一般会遇到的问题：&quot; class=&quot;headerlink&quot; title=&quot;4. 一般会遇到的问题：&quot;&gt;&lt;/a&gt;4. 一般会遇到的问题：&lt;/h4&gt;&lt;p&gt;windows上传到liunx上的文件一般都是权限错误和大小写问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod o+w temp
chmod o+w themes
chmod o+w cert -R
chmod o+w images -R
chmod o+w data -R
chmod o+w temp -R
chmod o+w themes -R
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连接mysql报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@localhost lib]# mysql -uroot -p
Enter password:
ERROR 2002 (HY000): Can&amp;apos;t connect to local MySQL server through socket                                         &amp;apos;/var/lib/mysql/mysql.sock&amp;apos; (2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;检查mysql状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/mysqld status;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;脚本启动mysql:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/inint.d/mysqld start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装时候报错：&lt;/p&gt;
&lt;p&gt;原因：（本地localhost连接走sock,可以直接输入127.0.0.1）&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;①修改/usr/local/httpd/lib/php.ini中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;; Default socket name for local MySQL connects.  If empty, uses the built-in
; MySQL defaults.
; http://php.net/mysql.default-socket
 mysql.default_socket = /var/lib/mysql/mysql.sock
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;② 强制关掉php-fpm进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkill -9 php-fpm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;③ 重启fpm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/httpd/sbin/php-fpm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;tips:&lt;/p&gt;
&lt;p&gt;查看具体的详细参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -uroot -p -e &amp;quot;show status\G;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;gzip-nginx压缩提升网速&quot;&gt;&lt;a href=&quot;#gzip-nginx压缩提升网速&quot; class=&quot;headerlink&quot; title=&quot;gzip+nginx压缩提升网速&quot;&gt;&lt;/a&gt;gzip+nginx压缩提升网速&lt;/h2&gt;&lt;h4 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1. 原理&quot;&gt;&lt;/a&gt;1. 原理&lt;/h4&gt;&lt;p&gt;浏览器-》请求-》声明可以接受的压缩（gzip defate compress sdch[google支持]）服务器-》回应-》把内容用gzip方式压缩-》发给浏览器浏览《-解码gzip《接收gzip压缩内容《&lt;/p&gt;
&lt;h4 id=&quot;2-配置常用参数&quot;&gt;&lt;a href=&quot;#2-配置常用参数&quot; class=&quot;headerlink&quot; title=&quot;2. 配置常用参数&quot;&gt;&lt;/a&gt;2. 配置常用参数&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;gzip on|off;               #是否开启gzip
gzip_buffers 32 4K| 16 8K  #缓冲(压缩在内存中缓冲几块? 每块多大?)
gzip_comp_level [1-9]      #推荐6 压缩级别(级别越高,压的越小,越浪费CPU资源)
gzip_disable               #正则匹配UA 什么样的Uri不进行gzip
gzip_min_length 200        # 开始压缩的最小长度(再小就不要压缩了,意义不在)
gzip_http_version 1.0|1.1  # 开始压缩的http协议版本(可以不设置,目前几乎全是1.1协议)
gzip_proxied               # 设置请求者代理服务器,该如何缓存内容
gzip_types text/plain application/xml # 对哪些类型的文件用压缩 如txt,xml,html ,css（html类型不写也会压缩）（可参考/usr/local/nginx/conf/mime.types）
gzip_vary on|off           # 是否传输gzip压缩标志
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要注意：&lt;/p&gt;
&lt;p&gt;①Transfer-Encoding: hunked代表分块传输，看不出长度&lt;/p&gt;
&lt;p&gt;②压缩长度不易太小&lt;/p&gt;
&lt;p&gt;③图片/MP3等二进制文件不必压缩（省不了多少还浪费资源）&lt;/p&gt;
&lt;h2 id=&quot;nginx设置缓存设置&quot;&gt;&lt;a href=&quot;#nginx设置缓存设置&quot; class=&quot;headerlink&quot; title=&quot;nginx设置缓存设置&quot;&gt;&lt;/a&gt;nginx设置缓存设置&lt;/h2&gt;&lt;h4 id=&quot;1-作用：&quot;&gt;&lt;a href=&quot;#1-作用：&quot; class=&quot;headerlink&quot; title=&quot;1. 作用：&quot;&gt;&lt;/a&gt;1. 作用：&lt;/h4&gt;&lt;p&gt;提高网站性能，提升负载&lt;/p&gt;
&lt;h4 id=&quot;2-应用场景&quot;&gt;&lt;a href=&quot;#2-应用场景&quot; class=&quot;headerlink&quot; title=&quot;2. 应用场景&quot;&gt;&lt;/a&gt;2. 应用场景&lt;/h4&gt;&lt;p&gt;新闻之类的一旦发布就很少改动的网站&lt;/p&gt;
&lt;h4 id=&quot;3-设置&quot;&gt;&lt;a href=&quot;#3-设置&quot; class=&quot;headerlink&quot; title=&quot;3. 设置&quot;&gt;&lt;/a&gt;3. 设置&lt;/h4&gt;&lt;p&gt;用nginx的expires设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;expires 1d;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果http请求不变浏览器就会把之前请求下来的资源拿来用，此时查看请求信息可以看到是304 和expires&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrpkn.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160428002126.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;编译php并与nginx整合,安装ecshop,gzip+nginx压缩提升网速,nginx设置缓存设置&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>nginx简单配置管理(3)</title>
    <link href="http://yoursite.com/2016/03/14/nginx-staudy-3/"/>
    <id>http://yoursite.com/2016/03/14/nginx-staudy-3/</id>
    <published>2016-03-14T10:17:14.000Z</published>
    <updated>2016-05-11T16:09:36.017Z</updated>
    
    <content type="html">&lt;p&gt;Location，rewrite 重写&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、Location&quot;&gt;&lt;a href=&quot;#一、Location&quot; class=&quot;headerlink&quot; title=&quot;一、Location&quot;&gt;&lt;/a&gt;一、Location&lt;/h3&gt;&lt;p&gt;1, 作用&lt;/p&gt;
&lt;p&gt;根据Uri来进行不同的定位，location可以把网站的不同部分,定位到不同的处理方式上&lt;/p&gt;
&lt;p&gt;2, 语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location [=|~|~*|^~] patt { }【参数可以省略】
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;三种参数类型：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;location = patt {} 【精准匹配】

location patt{} 【一般匹配】

location ~ patt{} 【正则匹配】
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;首先执行精准匹配，如果都匹配不到最终会定位到默认目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/html/
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;有正则匹配参与的情况，如果之前有匹配到的，正则也能匹配到的就会覆盖前面的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;location / {
             root /usr/local/nginx/html;
             index index.html index.htm;
         }

           location ~ image {
            root /var/www/image;
            index index.html;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;对于同样都能匹配的情况下会使用更详细的匹配条件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;location / {
              root /usr/local/nginx/html;
              index index.html index.htm;
 }

 location /foo {
             root /var/www/html;
             index index.html;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;匹配原则流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrpkn.com1.z0.glb.clouddn.com/3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、rewrite-重写&quot;&gt;&lt;a href=&quot;#二、rewrite-重写&quot; class=&quot;headerlink&quot; title=&quot;二、rewrite 重写&quot;&gt;&lt;/a&gt;二、rewrite 重写&lt;/h3&gt;&lt;p&gt;1，模块很多，通常碰到nginx新问题怎么解决？？？？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;到官网去查文档（在哪儿写，语法）      http://nginx.org/en/docs/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2，功能：域名跳转，域名镜像，防盗链，等。&lt;/p&gt;
&lt;p&gt;3，nginx有权引用的变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls conf/     fastcgi.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4，常用命令语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location / {
   # 判断相等
        if ($remote_addr = 192.168.33.1) {
           return 403;
         }

   # 正则匹配
          if ($http_user_agent ~ AppleWebK ) {
              rewrite ^.*$ /ge.html;
              break;
          }

   # -f -d -e来判断是否为文件,为目录,是否存在.
          if (!-e $document_root$fastcgi_script_name) {
               rewrite ^.*$  /404.html;
               break;
           }
     root   html;
     index  index.html index.htm;
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;set则用来设置变量，多条件判断时作标志用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;if ($http_user_agent ~* msie) {
     set $isie 1;
 }

if ($fastcgi_script_name = ie.html) {
     set $isie 0;
  }

if ($isie 1) {
     rewrite ^.*$ ie.html;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;tips:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中正则匹配和判断目录文件是都存在的模块break不可以少：服务器内部的rewrite和302跳转不一样访问路径不会改变&lt;/p&gt;
&lt;p&gt;如访问：xx.com/dsafsd.html，重写之后地址不会变，会循环重定向&lt;/p&gt;
&lt;p&gt;302跳转就是网址重定向的一种，它区别于301跳转，301是网址永久重定向，&lt;/p&gt;
&lt;p&gt;302  则 是 网址的临时定向。302转向或者302重定向（302 redirect）指的&lt;br&gt;是当浏览器要求一个网页的时候，主机所返回的状态码。302状态码的意义是&lt;br&gt;暂时转向到另外一个网址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5，ecshop正则重写练习&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模式规则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Rewrite 正则表达式 定向后的位置 模式

（根据url规则去匹配变的东西）（需要在ecshop后台设置url重写模式）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对应关系:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Goods-3.html ----&amp;gt;Goods.php?goods_id=3

goods-([\d]+)\.html ---&amp;gt; goods.php?goods_id =$1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /ecshop {
    index index.php;

    rewrite goods-([\d]+)\.html$ /ecshop/goods.php?id=$1;

    rewrite article-([\d]+)\.html$ /ecshop/article.php?id=$1;

    rewrite category-(\d+)-b(\d+)\.html /ecshop/category.php?id=$1&amp;amp;brand=$2;

    rewrite category-(\d+)-b(\d+)-min(\d+)-max(\d+)-attr([\d\.]+)\.html /ecshop/category.php?id=$1&amp;amp;brand=$2&amp;amp;price_min=$3&amp;amp;price_max=$4&amp;amp;filter_attr=$5;

    rewrite category-(\d+)-b(\d+)-min(\d+)-max(\d+)-attr([\d+\.])-(\d+)-([^-]+)-([^-]+)\.html /ecshop/category.php?id=$1&amp;amp;brand=$2&amp;amp;price_min=$3&amp;amp;price_max=$4&amp;amp;filter_attr=$5&amp;amp;page=$6&amp;amp;sort=$7&amp;amp;order=$8;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 遇到的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置nginx.conf重写时报403,原因没有制定访问文件&lt;/p&gt;
&lt;p&gt;rewrite 项里不能用 {} 可能是会与location{}的括号冲突 ，可以用\d+代替，也可以用双引号引起来&lt;/p&gt;
&lt;p&gt;当用复杂重写时，使用贪婪匹配时要把复杂的放前面，先去匹配，否则不准确&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Location，rewrite 重写&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="linux nignx" scheme="http://yoursite.com/tags/linux-nignx/"/>
    
  </entry>
  
  <entry>
    <title>nginx简单配置管理(2)</title>
    <link href="http://yoursite.com/2016/03/14/nginx-staudy-2/"/>
    <id>http://yoursite.com/2016/03/14/nginx-staudy-2/</id>
    <published>2016-03-14T09:17:14.000Z</published>
    <updated>2016-05-11T16:09:31.937Z</updated>
    
    <content type="html">&lt;p&gt;nginx 信号量，nginx假单配置，&lt;/p&gt;
&lt;p&gt;nginx日志管理，按时间转存日志&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;一、nginx-信号量&quot;&gt;&lt;a href=&quot;#一、nginx-信号量&quot; class=&quot;headerlink&quot; title=&quot;一、nginx 信号量&quot;&gt;&lt;/a&gt;一、nginx 信号量&lt;/h3&gt;&lt;p&gt;开启，关闭，重启&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill -INT 26661
     -TERM (紧急杀掉)
     -QUIT请求结束后在关闭
     -HUP改配置文件，平滑的重读配置文件
     -USR1重读日志，
     -USR2 升级用
     -WINCH优雅关闭旧程序配合usr1使用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill -HUP `cat logs/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以也哦那个命令来管理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./sbin/nginx -s reload stop
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二、nginx-简单配置&quot;&gt;&lt;a href=&quot;#二、nginx-简单配置&quot; class=&quot;headerlink&quot; title=&quot;二、nginx 简单配置&quot;&gt;&lt;/a&gt;二、nginx 简单配置&lt;/h3&gt;&lt;p&gt;nginx虚拟主机的配置&lt;/p&gt;
&lt;p&gt;  打开配置文件nginx.conf&lt;/p&gt;
&lt;p&gt;  全局区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;worker_processes 1;       工作的子进程数量,可以修改,但太大无益,因为要争夺CPU,一般设置为 CPU数*核数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  配置nginx连接的特性，如1个word能同时允许多少连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Event {
   worker_connections  1024; // 这是指 一个子进程最大允许连1024个连接
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  配置http服务器的主要段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http {
  Server1 { // 虚拟主机段
        Location {  //定位,把特殊的路径或文件再次定位 ,如image目录单独处理
        }             /// 如.php单独处理
 }

 Server2 {
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;简单的配置：&quot;&gt;&lt;a href=&quot;#简单的配置：&quot; class=&quot;headerlink&quot; title=&quot;简单的配置：&quot;&gt;&lt;/a&gt;简单的配置：&lt;/h6&gt;&lt;p&gt; 基于域名的虚拟主机&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen 80;
    server_name z.com;
    location / {
      root z.com;
      index.html;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;软重启nginx读取配置文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/nginx/sbin/nginx -s reload
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill -HUP `cat logs/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后解析host,访问z.com就可以访问了&lt;/p&gt;
&lt;h6 id=&quot;基于端口的虚拟主机配置&quot;&gt;&lt;a href=&quot;#基于端口的虚拟主机配置&quot; class=&quot;headerlink&quot; title=&quot;基于端口的虚拟主机配置&quot;&gt;&lt;/a&gt;基于端口的虚拟主机配置&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;server {
    listen 8080;
    server_name 192.168.1.204;

    location / {
            root /var/www/html8080;
            index index.html;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;三、nginx-简单日志管理&quot;&gt;&lt;a href=&quot;#三、nginx-简单日志管理&quot; class=&quot;headerlink&quot; title=&quot;三、nginx 简单日志管理&quot;&gt;&lt;/a&gt;三、nginx 简单日志管理&lt;/h3&gt;&lt;p&gt;打开配置文件会看到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nginx的server段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;#access_log  logs/host.access.log  main;（访问日志的文件是logs/host.access.log 使用main格式，也可以自定义格式）
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;main格式（是我们定义好一种日志的格式,并起个名字,便于引用 ）：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;log_format  main  &amp;apos;$remote_addr（远程IP ） - $remote_user [$time_local]（远程用户/用户时间 ） &amp;quot;$request&amp;quot;（请求方法(如GET/POST) ） &amp;apos;
#                 &amp;apos;$status $body_bytes_sent （请求体body长度 ）&amp;quot;$http_referer（referer来源信息 ）&amp;quot; &amp;apos;
#                 &amp;apos;&amp;quot;$http_user_agent（用户代理/蜘蛛 ,被转发的请求的原始IP ）&amp;quot; &amp;quot;$http_x_forwarded_for（在经过代理时,代理把你的本来IP加在此头信息中,传输你的原始IP ）&amp;quot;&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;声明一个独特的log_format并命名（选项可以自由选择）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;log_format  mylog &amp;apos;$remote_addr- &amp;quot;$request&amp;quot; &amp;apos;
                  &amp;apos;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &amp;apos;
                  &amp;apos;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;针对不同的server做不同的Log ,(有的web服务器不支持,如lighttp)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;access_log logs/access_8080.log mylog;
声明log           log位置                  log格式;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;四、按时间转存日志&quot;&gt;&lt;a href=&quot;#四、按时间转存日志&quot; class=&quot;headerlink&quot; title=&quot;四、按时间转存日志&quot;&gt;&lt;/a&gt;四、按时间转存日志&lt;/h3&gt;&lt;p&gt;1, 日志的定时切割，shell脚本，定时&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date -s &amp;apos;2015-12-28 17:32&amp;apos;     修改系统时间
clock -w                       修改后写入日志

date -d yesterday              查看昨天时间
date -d yesterday +%Y%m%d      格式化时间
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意：安装ntpdate时间服务器，更新系统时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2, 写脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;命名runlog.sh

#!/bin/bash
LOGPATH=/usr/local/nginx/logs/access.log (日志路径)
BASEPATH=/data (将要保存路径)


bak=$BASEPATH/$(date &amp;quot;+%Y-%m-%d-%H-%M-%S&amp;quot;).access.log（拼写命名路径）
#echo $bak

mv $LOGPATH $bak （把日志从原来路径移到拼写路径）
touch $LOGPATH （写入新的日志名）

kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`（重写日志）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3, 让脚本生效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;执行crontab -e
写入内容(分 时 日 月 周)
*/1 * * * * sh /data/runlog.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4， 如果想按月份创建目录按天切割管理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

LOGPATH=/usr/local/nginx/logs/host.access.log

BASEPATH=/data/$(date &amp;quot;+%Y%m&amp;quot;)

mkdir -p $BASEPATH

bak=$BASEPATH/$(date &amp;quot;+%d%H%M&amp;quot;).host.access.log
#echo $bak

mv $LOGPATH $bak
touch $LOGPATH

kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;nginx 信号量，nginx假单配置，&lt;/p&gt;
&lt;p&gt;nginx日志管理，按时间转存日志&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux nignx" scheme="http://yoursite.com/tags/linux-nignx/"/>
    
  </entry>
  
  <entry>
    <title>linux下nginx安装编译(1)</title>
    <link href="http://yoursite.com/2016/03/14/nginx-staudy-1/"/>
    <id>http://yoursite.com/2016/03/14/nginx-staudy-1/</id>
    <published>2016-03-14T06:17:14.000Z</published>
    <updated>2016-05-11T16:06:44.931Z</updated>
    
    <content type="html">&lt;p&gt;linux下nginx安装编译…&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;1, 地址：www.nginx.org        (尽量选择稳定版本)&lt;/p&gt;
&lt;p&gt;2, 复制安装地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget http://nginx.org/download/nginx-1.9.12.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这时候需要注意权限问题（需要切换至root用户，或者在命令前加sudo）：&lt;/p&gt;
&lt;p&gt;su 切换root用户     passwd： 修改密码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3, 进入到(/usr/local/src)解压安装包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf nginx-1.8.0.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4, 安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/usr/local/nginx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5，如果发现依赖没安装，再安装依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install pcre（正则表达式库）
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;结果提示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;setting up Install Process
Package pcre-7.8-6.e16.x86_64 already installed and latest verion
Nothing to do
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;查看有没有 pcre-devel, 执行安装命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;yum install pcre-devel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6，编译安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.安装完成后在 /usr/local/nginx下可以看到四个目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conf（配置文件）
html（放置网页文件）
logs（日志文件）
sbin（进程文件二进制程序）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  8，启动：&lt;br&gt;常见问题，端口被占用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrpkn.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160314152133.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查看占用端口情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrpkn.com1.z0.glb.clouddn.com/2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不能绑定 80端口，80 端口已经被占用&lt;/p&gt;
&lt;p&gt;有时是自己装了 apache，nginx等，还有更多情况是操作系统自带了 apache并作为服务启动&lt;/p&gt;
&lt;p&gt;解决办法：把占用80端口的软件或服务关闭即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看进程占用程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkill -9 http
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;linux下nginx安装编译…&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux nignx" scheme="http://yoursite.com/tags/linux-nignx/"/>
    
  </entry>
  
  <entry>
    <title>vagrant基本用法</title>
    <link href="http://yoursite.com/2016/03/09/vagrant-basic-use/"/>
    <id>http://yoursite.com/2016/03/09/vagrant-basic-use/</id>
    <published>2016-03-09T10:34:59.000Z</published>
    <updated>2016-04-21T09:44:00.459Z</updated>
    
    <content type="html">&lt;h4 id=&quot;vagrant-windows下基本使用&quot;&gt;&lt;a href=&quot;#vagrant-windows下基本使用&quot; class=&quot;headerlink&quot; title=&quot;vagrant windows下基本使用&quot;&gt;&lt;/a&gt;vagrant windows下基本使用&lt;/h4&gt;&lt;h6 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;Vagrant是一个基于Ruby的工具，用于创建和部署虚拟化开发环境。它 使用Oracle的开源VirtualBox虚拟化系统，使用 Chef创建自动化虚拟环境&lt;/p&gt;
&lt;p&gt;我们可以通过 Vagrant 封装一个 Linux 的开发环境，分发给团队成员。成员可以在自己喜欢的桌面系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，非常霸气&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h6 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h6&gt;&lt;p&gt;安装vagrant和虚拟机virtulbox（一般先下载安装virtulbox）&lt;/p&gt;
&lt;h6 id=&quot;下载地址：&quot;&gt;&lt;a href=&quot;#下载地址：&quot; class=&quot;headerlink&quot; title=&quot;下载地址：&quot;&gt;&lt;/a&gt;下载地址：&lt;/h6&gt;&lt;p&gt;. &lt;a href=&quot;https://www.vagrantup.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vagrant(选对应版本)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;. &lt;a href=&quot;https://www.virtualbox.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;virtulbox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装过程基本就是默认状态，最后在命令行输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vagrant
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;出现帮助信息代表安装完成&lt;/p&gt;
&lt;p&gt;. box镜像文件可想象成虚拟机的本身&lt;/p&gt;
&lt;h6 id=&quot;查看安装的box&quot;&gt;&lt;a href=&quot;#查看安装的box&quot; class=&quot;headerlink&quot; title=&quot;查看安装的box&quot;&gt;&lt;/a&gt;查看安装的box&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;vagrant box list
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;添加box&quot;&gt;&lt;a href=&quot;#添加box&quot; class=&quot;headerlink&quot; title=&quot;添加box&quot;&gt;&lt;/a&gt;添加box&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;vagrant box add  
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;下载地址：www.vagrantcloud.com  搜索centos 6.5 32&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;添加本地下载好的box&quot;&gt;&lt;a href=&quot;#添加本地下载好的box&quot; class=&quot;headerlink&quot; title=&quot;添加本地下载好的box&quot;&gt;&lt;/a&gt;添加本地下载好的box&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;vagrant box add  文件绝对路径
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;例如：复制box的名字：在命令行执行如：vagrant box add chef/centos-6.5  选择virtulbox&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;为项目创建个目录&quot;&gt;&lt;a href=&quot;#为项目创建个目录&quot; class=&quot;headerlink&quot; title=&quot;为项目创建个目录&quot;&gt;&lt;/a&gt;为项目创建个目录&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;md wangcan

cd wangcan

vagrant box list`
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;初始化项目目录&quot;&gt;&lt;a href=&quot;#初始化项目目录&quot; class=&quot;headerlink&quot; title=&quot;初始化项目目录&quot;&gt;&lt;/a&gt;初始化项目目录&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;vagrant init chef/centos-6.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时会出现vagrantfile文件（以后很多配置都在这里）&lt;/p&gt;
&lt;h6 id=&quot;启动虚拟机&quot;&gt;&lt;a href=&quot;#启动虚拟机&quot; class=&quot;headerlink&quot; title=&quot;启动虚拟机&quot;&gt;&lt;/a&gt;启动虚拟机&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;vagrant up
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;如果失败可以直接打开virtualbox看看报什么错误,针对提示一般都会找到解决方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动成功后显示类似如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;default：/vagrant =&amp;gt; /User/phoenix/wangcan
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;虚拟机的vagrant目录和本地的wangcan目录同步，此时修改本地就可以同步&lt;/p&gt;
&lt;p&gt;vagrnat ssh 可连接虚拟机，可以用客户端工具连接；127.0.0.1 端口：2222 用户和密码都是vagrant&lt;/p&gt;
&lt;p&gt;在windows命令窗口下清楚之前命令用 cls&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;vagrant status  #查看虚机状态
vagrant halt    #关机
vagrant suspend #暂停
vagrant reload  #先关机再启动
vagrant destroy #销毁当前的box,不会销毁原来的
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;虚拟机搭建好之后就可以安装开发环境了&lt;/p&gt;
&lt;p&gt;不过记得切换root用户&lt;/p&gt;
&lt;p&gt;或者使用sudo+命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;额外共享目录设置&quot;&gt;&lt;a href=&quot;#额外共享目录设置&quot; class=&quot;headerlink&quot; title=&quot;额外共享目录设置&quot;&gt;&lt;/a&gt;额外共享目录设置&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开vagrantfile&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;搜索打开:synced_folder项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;create:ture,owner:”root”, group:”root”     (目录不存在就创建，拥有者，群组)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重启vagrant up&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&quot;在虚拟机上配置web服务器&quot;&gt;&lt;a href=&quot;#在虚拟机上配置web服务器&quot; class=&quot;headerlink&quot; title=&quot;在虚拟机上配置web服务器&quot;&gt;&lt;/a&gt;在虚拟机上配置web服务器&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;可配置网络类型：&lt;/p&gt;
&lt;p&gt;私有=&amp;gt; 为虚拟机手工的制定一个ip地址，通过这个ip地址电脑和虚拟机间通讯，并且只能通过自己的电脑才能访问这个虚拟机，如果在这台虚拟机上搭建了一台服务器，那么只能在你的电脑上访问&lt;/p&gt;
&lt;p&gt;公有=&amp;gt; 同一个网络上可访问，同一个网络上的其他设备都可以访问&lt;/p&gt;
&lt;p&gt;端口转发 =&amp;gt; 配置好要转发的端口如8080 转发到80 访问本地8080会转发到细腻机80端口，这样不灵活，要手工配置多个端口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 私有网络配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;打开vagrantfile 搜索
  # config.vm.network &amp;quot;private_network&amp;quot;, ip: &amp;quot;192.168.33.10&amp;quot;
  打开重启虚拟机
  ping 192.168.33.10     测试能否通讯，（主机接受数据包返回信息）
  vagrant ssh  后输入 ifconfig              返回配置系统的网络信息
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;公有网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;打开vagrantfile 注释掉私有配置
搜索打开
# config.vm.network &amp;quot;public_network&amp;quot;
重启 -&amp;gt;    提示选择网络类型
ifconfig 查看 ip
用ip 就可以
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;package打包现有开发环境&quot;&gt;&lt;a href=&quot;#package打包现有开发环境&quot; class=&quot;headerlink&quot; title=&quot;package打包现有开发环境&quot;&gt;&lt;/a&gt;package打包现有开发环境&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;首先删除一个文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;rm -rf  /etc/udev/rules.d/70-persistent-net.rules
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;进入到醒目根目录执行如下命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;vagrant up
vagrant package –base virtualbox_vm_name –output newbox_name.box
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  在你的醒目下就存在了一个打包好的newbox_name.box&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vagrant package -h
 Usage: vagrant package [options] [name]
 Options:
    --base NAME                  virtualbox程序里面的虚拟机的名称，不是box的名字也不是Vagrantfile里面的虚拟机名称.默认是打包当前目录下面的虚拟机。
    --output NAME                要打包成的box名称，不会自动添加.box后缀，要手动加.默认值package.box
    --include FILE...            打包时包含的文件名，你可以把.box文件理解为一个压缩包
    --vagrantfile FILE           打包时包含的Vagrantfile文件，原理和上面类似
 -h, --help                       Print this help
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;把这个newbox_name.box文件拷贝到你到小伙伴到机器上；&lt;/li&gt;
&lt;li&gt;在机器上执行vagrant box add newbox_names newbox_name.box就可以把这个box添加到这台机器的box列表里面；&lt;/li&gt;
&lt;li&gt;在需要搭建开发环境的目录下面执行vagrant init newbox_names,这样就初始化了一个虚拟机环境，然后执行vagrant up,&lt;br&gt;你的小伙伴就可以得到一个和你完全一样的开发环境了。&lt;br&gt;在初始化环境的时候需要注意的一点是：这个目录下面如果以前初始化过，那么请执行vagrant destroy命令把这个环境销毁掉，&lt;br&gt;并删除Vagrantfile文件，或者在windows环境下直接手动删除.vagrant目录和Vagrantfile文件有相同的效果。否则vagrant init命令无效，&lt;br&gt;当你vagant up的时候得到的是一个和以前完全一样的环境。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这段话参考自：&lt;a href=&quot;http://ju.outofmemory.cn/entry/101516&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ju.outofmemory.cn/entry/101516&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tips:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;su 切换root用户     passwd： 修改密码
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;vagrant-windows下基本使用&quot;&gt;&lt;a href=&quot;#vagrant-windows下基本使用&quot; class=&quot;headerlink&quot; title=&quot;vagrant windows下基本使用&quot;&gt;&lt;/a&gt;vagrant windows下基本使用&lt;/h4&gt;&lt;h6 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;Vagrant是一个基于Ruby的工具，用于创建和部署虚拟化开发环境。它 使用Oracle的开源VirtualBox虚拟化系统，使用 Chef创建自动化虚拟环境&lt;/p&gt;
&lt;p&gt;我们可以通过 Vagrant 封装一个 Linux 的开发环境，分发给团队成员。成员可以在自己喜欢的桌面系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，非常霸气&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="small-tool" scheme="http://yoursite.com/categories/small-tool/"/>
    
    
      <category term="small-tool" scheme="http://yoursite.com/tags/small-tool/"/>
    
  </entry>
  
  <entry>
    <title>Git 介绍与使用</title>
    <link href="http://yoursite.com/2016/03/08/git/"/>
    <id>http://yoursite.com/2016/03/08/git/</id>
    <published>2016-03-08T10:34:59.000Z</published>
    <updated>2016-03-11T05:44:02.469Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最流行的分布式版本控制系统。&lt;/p&gt;
&lt;p&gt;Git有什么特点？&lt;/p&gt;
&lt;p&gt;免费而超级好用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Git安装&quot;&gt;&lt;a href=&quot;#Git安装&quot; class=&quot;headerlink&quot; title=&quot;Git安装&quot;&gt;&lt;/a&gt;Git安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 在Linux上安装Git&lt;/p&gt;
&lt;p&gt;首先你可以试着输入&lt;strong&gt;git&lt;/strong&gt;，看看系统有没有安装Git！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git
usage: git [--version] [--exec-path[=GIT_EXEC_PATH]] [--html-path]
       [-p|--paginate|--no-pager] [--no-replace-objects]
       [--bare] [--git-dir=GIT_DIR] [--work-tree=GIT_WORK_TREE]
       [--help] COMMAND [ARGS]

The most commonly used git commands are:
   add        Add file contents to the index
     bisect     Find by binary search the change that     introduced a bug
     branch     List, create, or delete branches
     checkout   Checkout a branch or paths to the working     tree
   clone      Clone a repository into a new directory
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   fetch      Download objects and refs from another repository
   grep       Print lines matching a pattern
   init       Create an empty git repository or reinitialize an existing one
   log        Show commit logs
   merge      Join two or more development histories together
   mv         Move or rename a file, a directory, or a symlink
   pull       Fetch from and merge with another repository or a local branch
   push       Update remote refs along with associated objects
   rebase     Forward-port local commits to the updated upstream head
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index
   show       Show various types of objects
   status     Show the working tree status
   tag        Create, list, delete or verify a tag object signed with GPG

See &amp;apos;git help COMMAND&amp;apos; for more information on a specific command.
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;像上面的命令,如果是这样的证明你的系统已然存在git 不需要去安装了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git
The program &amp;apos;git&amp;apos; is currently not installed. You can install it by typing:
sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;如果碰到这种情况，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。别慌，现在我来带你安装git!&lt;/p&gt;
&lt;p&gt;如果你碰巧用Debian或Ubuntu Linux，运行下面这条命令就可以直接完成Git的安装，非常简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;如果你的Debian或Ubuntu Linux太老了，那试试下面这条命令！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install git-core
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：&lt;strong&gt;./config，make，sudo make install&lt;/strong&gt;这几个命令安装就好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;在Mac-OS-X上安装Git&quot;&gt;&lt;a href=&quot;#在Mac-OS-X上安装Git&quot; class=&quot;headerlink&quot; title=&quot;在Mac OS X上安装Git&quot;&gt;&lt;/a&gt;在Mac OS X上安装Git&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;下面我提供两种安装Git的方法,这里我们推荐使用第二种！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：&lt;a href=&quot;http://brew.sh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://brew.sh/&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&amp;gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;在Windows上安装Git&quot;&gt;&lt;a href=&quot;#在Windows上安装Git&quot; class=&quot;headerlink&quot; title=&quot;在Windows上安装Git&quot;&gt;&lt;/a&gt;在Windows上安装Git&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;说实话&lt;strong&gt;windows&lt;/strong&gt;是非常垃圾的开发平台，个人不推荐。但是好多人都用这款操作系统，我们还是说一下吧。&lt;/p&gt;
&lt;p&gt;msysgit是Windows版的Git，点击下面这条链接下载到本地！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dlsw.baidu.com/sw-search-sp/soft/4e/30195/Git_V2.5.1_64_bit_setup.1441791170.exe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dlsw.baidu.com/sw-search-sp/soft/4e/30195/Git_V2.5.1_64_bit_setup.1441791170.exe&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们使用的是Git Bash。去你的应用里面打开这个，会出现一个类似cmd的黑色窗口，恭喜你，成功安装&lt;strong&gt;windows&lt;/strong&gt;版本&lt;strong&gt;git&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;以上安装完成后，还需要最后一步设置，在命令行输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global user.name &amp;quot;Your Name&amp;quot;
$ git config --global user.email &amp;quot;email@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址&lt;/p&gt;
&lt;p&gt;例如如果你公司的项目是放在自建的gitlab上面, 如果你不进行配置用户名和邮箱的话, 则会使用全局的, 这个时候是错误的, 正确的做法是针对公司的项目, 在项目根目录下进行单独配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git config user.name &amp;quot;Your Name&amp;quot;
$ git config user.email &amp;quot;email@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;那我们应该怎么去看，我们做的一些配置呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git config --list
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这个命令查看的是当前配置, 在当前项目下面查看的配置是全局配置+当前项目的配置, 使用的时候会优先使用当前项目的配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何操作？&quot;&gt;&lt;a href=&quot;#如何操作？&quot; class=&quot;headerlink&quot; title=&quot;如何操作？&quot;&gt;&lt;/a&gt;如何操作？&lt;/h2&gt;&lt;h3 id=&quot;一：创建版本库&quot;&gt;&lt;a href=&quot;#一：创建版本库&quot; class=&quot;headerlink&quot; title=&quot;一：创建版本库&quot;&gt;&lt;/a&gt;一：创建版本库&lt;/h3&gt;&lt;h4 id=&quot;版本库是什么？&quot;&gt;&lt;a href=&quot;#版本库是什么？&quot; class=&quot;headerlink&quot; title=&quot;版本库是什么？&quot;&gt;&lt;/a&gt;版本库是什么？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;版本库又名仓库，也就是我们常见的repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。是不是很屌？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;创建版本库&quot;&gt;&lt;a href=&quot;#创建版本库&quot; class=&quot;headerlink&quot; title=&quot;创建版本库&quot;&gt;&lt;/a&gt;创建版本库&lt;/h4&gt;&lt;p&gt;&lt;strong&gt; 上文说到他很屌，但是创建起来确实非常的简单！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们只需要选择一个适合的地方，创建一个空目录即可！我们来举个栗子！其实都是一样的！不过这里注意一下，尽量不要用中文命名！就算为了我们的逼格也千万别用！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir www/git/myStudy -p
$ cd www/git/myStudy
$ pwd
/d/www/git/myStudy
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;下面我们将要用到一个很牛的命令瞬间把这块地方变成你的仓库！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git init
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;如果你看到出现这种提示，证明你成功了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;Initialized empty Git repository in /root/git/my-study/.git/
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这时候你当前目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，就会把git仓库给破坏了！你可以用这个命令来查看一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ ls -ah
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;把文件添加到版本库&quot;&gt;&lt;a href=&quot;#把文件添加到版本库&quot; class=&quot;headerlink&quot; title=&quot;把文件添加到版本库&quot;&gt;&lt;/a&gt;把文件添加到版本库&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;接下来简单说几点需要注意的&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。&lt;/li&gt;
&lt;li&gt;Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。&lt;/li&gt;
&lt;li&gt;千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;下面我们继续，首先我们在当前目录下来创建一个文件，代码如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ touch readme.md
$ vi readme.md
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;我们随便在里面写一些东西进去然后保存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;we are family
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;那么我们怎么去把这个文件放到仓库里面呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1    用命令git add告诉Git，把文件添加到仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git add readme.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2    用命令git commit告诉Git，把文件提交到仓库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;quot;wrote a readme file&amp;quot;
[master (root-commit) cb926e7] wrote a readme file
1 file changed, 1 insertions(+)
 create mode 100644 readme.txt
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;上面的意思其实就是，1个文件被改动（我们新添加的readme.txt文件），插入了一行内容（we are family）。&lt;strong&gt;-m “wrote a readme file”&lt;/strong&gt;其实就是加了注释，这是作为一个程序员的基本准则！&lt;strong&gt;切记！切记！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m &amp;quot;add 3 files.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;我们也可以不用add，当我们提交一个项目，或者文件比较多，基本没问题的前提下可以用下面的代码：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git commit -am &amp;quot;add all&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二：git-常用的命令&quot;&gt;&lt;a href=&quot;#二：git-常用的命令&quot; class=&quot;headerlink&quot; title=&quot;二：git 常用的命令&quot;&gt;&lt;/a&gt;二：git 常用的命令&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当我们运行git时会出现这样的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;add        Add file contents to the index
bisect     Find by binary search the change that introduced a bug
branch     List, create, or delete branches
checkout   Checkout a branch or paths to the working tree
clone      Clone a repository into a new directory
commit     Record changes to the repository
diff       Show changes between commits, commit and working tree, etc
fetch      Download objects and refs from another repository
grep       Print lines matching a pattern
init       Create an empty git repository or reinitialize an existing one
log        Show commit logs
merge      Join two or more development histories together
mv         Move or rename a file, a directory, or a symlink
pull       Fetch from and merge with another repository or a local branch
push       Update remote refs along with associated objects
rebase     Forward-port local commits to the updated upstream head
reset      Reset current HEAD to the specified state
rm         Remove files from the working tree and from the index
show       Show various types of objects
status     Show the working tree status
tag        Create, list, delete or verify a tag
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;其实这些都是 git的命令 下面我们就来说一说我们常用的命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;git-status命令可以让我们时刻掌握仓库当前的状态&quot;&gt;&lt;a href=&quot;#git-status命令可以让我们时刻掌握仓库当前的状态&quot; class=&quot;headerlink&quot; title=&quot;git status命令可以让我们时刻掌握仓库当前的状态&quot;&gt;&lt;/a&gt;git status命令可以让我们时刻掌握仓库当前的状态&lt;/h4&gt;&lt;p&gt;   $ git status&lt;/p&gt;
&lt;h1 id=&quot;On-branch-master&quot;&gt;&lt;a href=&quot;#On-branch-master&quot; class=&quot;headerlink&quot; title=&quot;On branch master&quot;&gt;&lt;/a&gt;On branch master&lt;/h1&gt;&lt;h1 id=&quot;Changes-not-staged-for-commit&quot;&gt;&lt;a href=&quot;#Changes-not-staged-for-commit&quot; class=&quot;headerlink&quot; title=&quot;Changes not staged for commit:&quot;&gt;&lt;/a&gt;Changes not staged for commit:&lt;/h1&gt;&lt;h1 id=&quot;use-“git-add-…”-to-update-what-will-be-committed&quot;&gt;&lt;a href=&quot;#use-“git-add-…”-to-update-what-will-be-committed&quot; class=&quot;headerlink&quot; title=&quot;(use “git add …” to update what will be committed)&quot;&gt;&lt;/a&gt;(use “git add &lt;file&gt;…” to update what will be committed)&lt;/file&gt;&lt;/h1&gt;&lt;h1 id=&quot;use-“git-checkout-–-…”-to-discard-changes-in-working-directory&quot;&gt;&lt;a href=&quot;#use-“git-checkout-–-…”-to-discard-changes-in-working-directory&quot; class=&quot;headerlink&quot; title=&quot;(use “git checkout – …” to discard changes in working directory)&quot;&gt;&lt;/a&gt;(use “git checkout – &lt;file&gt;…” to discard changes in working directory)&lt;/file&gt;&lt;/h1&gt;&lt;p&gt;   #&lt;/p&gt;
&lt;h1 id=&quot;modified-readme-txt&quot;&gt;&lt;a href=&quot;#modified-readme-txt&quot; class=&quot;headerlink&quot; title=&quot;modified:   readme.txt&quot;&gt;&lt;/a&gt;modified:   readme.txt&lt;/h1&gt;&lt;p&gt;   #&lt;br&gt;   no changes added to commit (use “git add” and/or “git commit -a”)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;git-diff查看差异，显示的格式正是Unix通用的diff格式-如果加上具体某个文件名，就可以具体对比某个文件了！&quot;&gt;&lt;a href=&quot;#git-diff查看差异，显示的格式正是Unix通用的diff格式-如果加上具体某个文件名，就可以具体对比某个文件了！&quot; class=&quot;headerlink&quot; title=&quot;git diff查看差异，显示的格式正是Unix通用的diff格式,如果加上具体某个文件名，就可以具体对比某个文件了！&quot;&gt;&lt;/a&gt;git diff查看差异，显示的格式正是Unix通用的diff格式,如果加上具体某个文件名，就可以具体对比某个文件了！&lt;/h4&gt;&lt;p&gt;   diff –git a/Learning-growth/git/test.md b/Learning-growth/git/test.md&lt;br&gt;   index 4dad973..ec71f80 100644&lt;br&gt;   — a/Learning-growth/git/test.md&lt;br&gt;   +++ b/Learning-growth/git/test.md&lt;br&gt;   @@ -1 +1 @@&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hello word!&lt;br&gt;+hello word!&lt;br&gt;diff –git a/readme.md b/readme.md&lt;br&gt;index 55bef5e..f4370ba 100644&lt;br&gt;— a/readme.md&lt;br&gt;+++ b/readme.md&lt;br&gt;@@ -1,2 +1,2 @@&lt;/li&gt;
&lt;li&gt;we are familu!&lt;br&gt;+we are familu!
　&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;可以告诉我们历史记录，在Git中，我们用git-log命令查看：&quot;&gt;&lt;a href=&quot;#可以告诉我们历史记录，在Git中，我们用git-log命令查看：&quot; class=&quot;headerlink&quot; title=&quot;可以告诉我们历史记录，在Git中，我们用git log命令查看：&quot;&gt;&lt;/a&gt;可以告诉我们历史记录，在Git中，我们用git log命令查看：&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    $ git log
    commit b8d7cbd8d3b5585e495fdf8f0f79a13e8e106fb7
    Author: cuijiji &amp;lt;624337224@qq.com&amp;gt;
    Date:   Wed Feb 3 18:07:28 2016 +0800
    add all

    commit 57b37b7e743b0790213d97fb55d0664c2b18794c
    Author: cuijiji &amp;lt;624337224@qq.com&amp;gt;
    Date:   Wed Feb 3 18:05:25 2016 +0800

    add a folder

    commit 66d1757cfcc8d1476a23387b133125dc0efb2b96
    Author: cuijiji &amp;lt;624337224@qq.com&amp;gt;
    Date:   Wed Feb 3 17:49:55 2016 +0800

    add a new file

如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：

    $ git log --pretty=oneline

    b8d7cbd8d3b5585e495fdf8f0f79a13e8e106fb7 add all
    57b37b7e743b0790213d97fb55d0664c2b18794c add a folder
    66d1757cfcc8d1476a23387b133125dc0efb2b96 add a new file
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;我们要把当前版本回退到上一个版本就可以使用git-reset命令：&quot;&gt;&lt;a href=&quot;#我们要把当前版本回退到上一个版本就可以使用git-reset命令：&quot; class=&quot;headerlink&quot; title=&quot;我们要把当前版本回退到上一个版本就可以使用git reset命令：&quot;&gt;&lt;/a&gt;我们要把当前版本回退到上一个版本就可以使用git reset命令：&lt;/h4&gt;&lt;p&gt;   $ git reset –hard HEAD^&lt;br&gt;   HEAD is now at ea34578 add distributed&lt;/p&gt;
&lt;p&gt;^代表回退上N个版本所以^^代表两个不过如果太往前的我们就会用commit id(这个ID 不用写全 只要前几位保证没有重复即可)&lt;/p&gt;
&lt;p&gt;   $ git reset –hard 3628164&lt;br&gt;   HEAD is now at 3628164 append GPL&lt;/p&gt;
&lt;h3 id=&quot;三：git的工作区和暂存区的概念&quot;&gt;&lt;a href=&quot;#三：git的工作区和暂存区的概念&quot; class=&quot;headerlink&quot; title=&quot;三：git的工作区和暂存区的概念&quot;&gt;&lt;/a&gt;三：git的工作区和暂存区的概念&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;简单以下几点&quot;&gt;&lt;a href=&quot;#简单以下几点&quot; class=&quot;headerlink&quot; title=&quot;简单以下几点&quot;&gt;&lt;/a&gt;简单以下几点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;工作区及我们本地仓库的区域，&lt;/li&gt;
&lt;li&gt;暂存区及我们add上去的区域&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;那么我们commit到了哪里了呢？&quot;&gt;&lt;a href=&quot;#那么我们commit到了哪里了呢？&quot; class=&quot;headerlink&quot; title=&quot;那么我们commit到了哪里了呢？&quot;&gt;&lt;/a&gt;那么我们commit到了哪里了呢？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;那我们接下来说几个与这个有关的命令吧&quot;&gt;&lt;a href=&quot;#那我们接下来说几个与这个有关的命令吧&quot; class=&quot;headerlink&quot; title=&quot;那我们接下来说几个与这个有关的命令吧&quot;&gt;&lt;/a&gt;那我们接下来说几个与这个有关的命令吧&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;git checkout – file可以丢弃工作区的修改,也就是让这个文件回到最近一次git commit或git add时的状态：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -- readme.txt
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;$ git reset HEAD readme.txt
Unstaged changes after reset:
M       readme.txt
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;rm可以删除工作区的文件这时候你可以有两种方式来处理&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;第一种从版本库中删除该文件&quot;&gt;&lt;a href=&quot;#第一种从版本库中删除该文件&quot; class=&quot;headerlink&quot; title=&quot;第一种从版本库中删除该文件&quot;&gt;&lt;/a&gt;第一种从版本库中删除该文件&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;$ git rm test.txt
rm &amp;apos;test.txt&amp;apos;
$ git commit -m &amp;quot;remove test.txt&amp;quot;
[master d17efd8] remove test.txt
1 file changed, 1 deletion(-)
delete mode 100644 test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&quot;另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本&quot;&gt;&lt;a href=&quot;#另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本&quot; class=&quot;headerlink&quot; title=&quot;另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本&quot;&gt;&lt;/a&gt;另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;$ git checkout -- test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;四：远程仓库&quot;&gt;&lt;a href=&quot;#四：远程仓库&quot; class=&quot;headerlink&quot; title=&quot;四：远程仓库&quot;&gt;&lt;/a&gt;四：远程仓库&lt;/h3&gt;&lt;h4 id=&quot;什么是远程仓库？&quot;&gt;&lt;a href=&quot;#什么是远程仓库？&quot; class=&quot;headerlink&quot; title=&quot;什么是远程仓库？&quot;&gt;&lt;/a&gt;什么是远程仓库？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;那我们怎么办呢？&quot;&gt;&lt;a href=&quot;#那我们怎么办呢？&quot; class=&quot;headerlink&quot; title=&quot;那我们怎么办呢？&quot;&gt;&lt;/a&gt;那我们怎么办呢？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;下面我们来说说具体怎么去做吧&quot;&gt;&lt;a href=&quot;#下面我们来说说具体怎么去做吧&quot; class=&quot;headerlink&quot; title=&quot;下面我们来说说具体怎么去做吧&quot;&gt;&lt;/a&gt;下面我们来说说具体怎么去做吧&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;注册GitHub账号，不会的去找教程，我这里不说了！&lt;/li&gt;
&lt;li&gt;创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key。如果一切顺利的话，可以在用户主目录里找到.ssh目录，获取id_rsa.pub里面的内容&lt;/li&gt;
&lt;li&gt;登陆GitHub，打开“Account settings”，“SSH Keys”页面：&lt;br&gt;然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：点“Add Key”，你就应该看到已经添加的Key：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;与仓库链接&quot;&gt;&lt;a href=&quot;#与仓库链接&quot; class=&quot;headerlink&quot; title=&quot;与仓库链接&quot;&gt;&lt;/a&gt;与仓库链接&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库&lt;/li&gt;
&lt;li&gt;在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：&lt;/li&gt;
&lt;li&gt;&lt;p&gt;鉴于我们大多数都是以clone为主，我们就使用下面的代码运行&lt;/p&gt;
&lt;p&gt;git clone git@github.com:cuijiji/study-and-grow-up.git&lt;/p&gt;
&lt;p&gt;这样你就把你的远程仓库克隆下来了！现在我们重复之前的命令来修改，或者添加一个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在我们用下面的命令来提到我们的github上面吧&lt;/p&gt;
&lt;p&gt; git push -u origin master&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 你可能会碰到权限问题，换种链接方式试试！或者联系我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;五：创建与合并分支&quot;&gt;&lt;a href=&quot;#五：创建与合并分支&quot; class=&quot;headerlink&quot; title=&quot;五：创建与合并分支&quot;&gt;&lt;/a&gt;五：创建与合并分支&lt;/h3&gt;&lt;h4 id=&quot;什么是分支？&quot;&gt;&lt;a href=&quot;#什么是分支？&quot; class=&quot;headerlink&quot; title=&quot;什么是分支？&quot;&gt;&lt;/a&gt;什么是分支？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;分支就好比数学中平行的几条线！他们之间无不影响，都在自己的世界工作！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;到底是什么？举个栗子说明！&quot;&gt;&lt;a href=&quot;#到底是什么？举个栗子说明！&quot; class=&quot;headerlink&quot; title=&quot;到底是什么？举个栗子说明！&quot;&gt;&lt;/a&gt;到底是什么？举个栗子说明！&lt;/h4&gt;&lt;blockquote&gt;
&lt;h5 id=&quot;这个问题问的好（自问自答）！但是首先我们要再来理解一下这个概念。经过上面的学习或许你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。这样说你是否清楚了呢？不清楚没办法！有招想去，没招联系我！&quot;&gt;&lt;a href=&quot;#这个问题问的好（自问自答）！但是首先我们要再来理解一下这个概念。经过上面的学习或许你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。这样说你是否清楚了呢？不清楚没办法！有招想去，没招联系我！&quot; class=&quot;headerlink&quot; title=&quot;这个问题问的好（自问自答）！但是首先我们要再来理解一下这个概念。经过上面的学习或许你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。这样说你是否清楚了呢？不清楚没办法！有招想去，没招联系我！&quot;&gt;&lt;/a&gt;这个问题问的好（自问自答）！但是首先我们要再来理解一下这个概念。经过上面的学习或许你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。这样说你是否清楚了呢？不清楚没办法！有招想去，没招联系我！&lt;/h5&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;来创建dev分支，然后切换到dev分支上&quot;&gt;&lt;a href=&quot;#来创建dev分支，然后切换到dev分支上&quot; class=&quot;headerlink&quot; title=&quot;来创建dev分支，然后切换到dev分支上&quot;&gt;&lt;/a&gt;来创建dev分支，然后切换到dev分支上&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;使用下面的命令来创建一个分支dev&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有没有想起来我们之前好像用过这个checkout命令呢？好吧，想不起来算了！那我们重点说下这个命令的意思，其实它是涵盖这一下两个命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch dev

$ git checkout dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么我们现在试试这个git branch命令的效果吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch
 * dev
 master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;git branch&lt;/strong&gt;会列出所有的分支，前面带*的分支就是我们当前工作的分支！那我们怎么去切换分支呢？很简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout master
Switched to branch &amp;apos;master&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在我们切回dev分支修改一下自己做个测试，然后提交。再切回master，看看你刚才更改的文件是否有跟着变动呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;答案是&lt;strong&gt;没有&lt;/strong&gt;。&lt;strong&gt;为什么？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题问的真傻？不是说了吗平行，平行的……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;合并分支&quot;&gt;&lt;a href=&quot;#合并分支&quot; class=&quot;headerlink&quot; title=&quot;合并分支&quot;&gt;&lt;/a&gt;合并分支&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;合并分支其实很简单，使用下面这个命令即可：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git merge dev
Updating d17efd8..fec145a
Fast-forward
 readme.txt |    1 +
 1 file changed, 1 insertion(+)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;屌不屌？我就想问一句，&lt;strong&gt;还有谁？&lt;/strong&gt;这里我们对这个命令说明一下，&lt;strong&gt;git merge命令用于合并指定分支到当前分支&lt;/strong&gt;所以保证要合并到的是当前分支，也要注意你要合并的分支！&lt;strong&gt;切记切记！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没参数的情况下merge是&lt;strong&gt;fast-forward&lt;/strong&gt;的，即Git将master分支的指针直接移到dev的最前方。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单移动指针，所以这种合并成为快进式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上的那种我们称之为直接合并！我们还可以试试这种合并：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一条分支上的若干个提交条目压合成一个提交条目，提交到另一条分支的末梢。把dev分支上的所有提交压合成主分支上的一个提交，即压合提交：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge --squash dev
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;此时，dev上的所有提交已经合并到当前工作区并暂存，但还没有作为一个提交，可以像其他提交一样，把这个改动提交到版本库中：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;br&gt;    $ git commit –m “something from dev”&lt;/p&gt;
&lt;p&gt;拣选另一条分支上的某个提交条目的改动带到当前分支上。&lt;br&gt;每一次提交都会产生一个全局唯一的提交名称，利用这个名称就可以进行拣选提交。&lt;br&gt;比如在dev上的某个提交叫：321d76f&lt;em&gt;*&lt;/em&gt;，我们现在把它合并到master&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git cherry-pick 321d76f
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;要拣选多个提交，可以给git cherry-pick命令传递-n选项，比如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;br&gt;    $ git cherry-pick –n 321d76f&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这样在拣选了这个改动之后，进行暂存而不立即提交，接着可以进行下一个拣选操作，一旦拣选完需要的各个提交，就可以一并提交。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;删除分支&quot;&gt;&lt;a href=&quot;#删除分支&quot; class=&quot;headerlink&quot; title=&quot;删除分支&quot;&gt;&lt;/a&gt;删除分支&lt;/h3&gt;&lt;p&gt;像我这么正直的人，爱做的就是卸磨杀驴！用完了怎么删除？试试这个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -d dev
Deleted branch dev (was fec145a).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就删除了，其实我们是为了不让自己混乱，因为分支一多就蒙圈了！&lt;/p&gt;
&lt;h3 id=&quot;六：解决冲突&quot;&gt;&lt;a href=&quot;#六：解决冲突&quot; class=&quot;headerlink&quot; title=&quot;六：解决冲突&quot;&gt;&lt;/a&gt;六：解决冲突&lt;/h3&gt;&lt;h4 id=&quot;为什么拿出这个重点说下，因为版本控制器，最蛋疼的问题就是冲突！所以我来告诉大家怎么去解决&quot;&gt;&lt;a href=&quot;#为什么拿出这个重点说下，因为版本控制器，最蛋疼的问题就是冲突！所以我来告诉大家怎么去解决&quot; class=&quot;headerlink&quot; title=&quot;为什么拿出这个重点说下，因为版本控制器，最蛋疼的问题就是冲突！所以我来告诉大家怎么去解决&quot;&gt;&lt;/a&gt;为什么拿出这个重点说下，因为版本控制器，最蛋疼的问题就是冲突！所以我来告诉大家怎么去解决&lt;/h4&gt;&lt;p&gt;首先我们想要解决冲突，就制造个冲突出来。很简单，还记得我们的分支吗？对了，就是这个！我就不在这里重复了，直接来命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b dev
$  git checkout dev
$  vim README.md
$  git add README.md
$  git commit -m &amp;apos;test test&amp;apos;
$  git branch
$  git branch master
$  git checkout master
$  vim README.md
$  git add README.md
$  git commit -m &amp;apos;test master&amp;apos;
$  git merge dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你看到的是这样的提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那恭喜你，你冲突了！怎么办？解决！你可以用之前我们用过的命令看一下状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git status
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你也可以看到哪个文件冲突了！那么我们现在打开刚刚冲突的文件来看一看！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
## 666
=======
## 777
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; dev
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;解释一下：&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;标记冲突开始，后面跟的是当前分支中的内容。&lt;/p&gt;
&lt;p&gt;　　HEAD指向当前分支末梢的提交。&lt;/p&gt;
&lt;p&gt;　　=======之后，&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;之前是要merge过来的另一条分支上的代码。&lt;/p&gt;
&lt;p&gt;　　&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;之后的dev是该分支的名字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对于简单的合并，手工编辑，然后去掉这些标记，最后像往常的提交一样先add再commit即可。我们可以通过下面这个命令来具体看一下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --graph --pretty=oneline --abbrev-commit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你会看见类似这样的提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   10fcd7a modify README.md
|\  
| * f9b6554 test test
* | 7d60f76 test master
|/  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有没有很好懂，但是那个git log 后面跟的一长串 都不记不住。怎么办？下面我来告诉你！怎么把命令简化！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global alias.lg &amp;quot;log --graph --pretty=oneline --abbrev-commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来你在运行一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git lg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到了什么？神奇吧！不解释！按照这个写法，你自己去定制几个试试吧！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最流行的分布式版本控制系统。&lt;/p&gt;
&lt;p&gt;Git有什么特点？&lt;/p&gt;
&lt;p&gt;免费而超级好用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="small-tool" scheme="http://yoursite.com/categories/small-tool/"/>
    
    
      <category term="small-tool" scheme="http://yoursite.com/tags/small-tool/"/>
    
  </entry>
  
  <entry>
    <title>makdown基础用法</title>
    <link href="http://yoursite.com/2016/03/07/makdown-diary/"/>
    <id>http://yoursite.com/2016/03/07/makdown-diary/</id>
    <published>2016-03-07T09:53:51.000Z</published>
    <updated>2016-03-11T05:39:40.883Z</updated>
    
    <content type="html">&lt;h2 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;apos;#&amp;apos;号后加空格，几个#就是几级标题，一共6级标题
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;无序列表&quot;&gt;&lt;a href=&quot;#无序列表&quot; class=&quot;headerlink&quot; title=&quot;无序列表&quot;&gt;&lt;/a&gt;无序列表&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;需要在文字前加上 - 或 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;即可变为无序列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;有序列表&quot;&gt;&lt;a href=&quot;#有序列表&quot; class=&quot;headerlink&quot; title=&quot;有序列表&quot;&gt;&lt;/a&gt;有序列表&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;有序列表则直接在文字前加 1. 2. 3.&lt;/li&gt;
&lt;li&gt;符号要和文字之间加上一个字符的空格。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;如果你需要引用一小段别处的句子，那么就要用引用的格式。&lt;br&gt;只需要在文本前加入 &amp;gt; 这种尖括号（大于号）即可&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里是引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要注意符号和文本的空格&lt;/p&gt;
&lt;p&gt;##图片与连接&lt;br&gt;插入链接与插入图片的语法很像，区别在一个 !号&lt;/p&gt;
&lt;p&gt;插入图片的地址需要图床，这里推荐 CloudApp 的服务，生成URL地址即可。&lt;br&gt;&lt;a href=&quot;http://baidu.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;baidu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mouapp.com/Mou_128.png&quot; alt=&quot;mou icom&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;粗体与斜体&quot;&gt;&lt;a href=&quot;#粗体与斜体&quot; class=&quot;headerlink&quot; title=&quot;粗体与斜体&quot;&gt;&lt;/a&gt;粗体与斜体&lt;/h2&gt;&lt;p&gt;Markdown 的粗体和斜体也非常简单，用两个 &lt;em&gt; 包含一段文本就是粗体的语法，用一个 &lt;/em&gt; 包含一段文本就是斜体的语法。&lt;/p&gt;
&lt;h2 id=&quot;表格&quot;&gt;&lt;a href=&quot;#表格&quot; class=&quot;headerlink&quot; title=&quot;表格&quot;&gt;&lt;/a&gt;表格&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;代码框&quot;&gt;&lt;a href=&quot;#代码框&quot; class=&quot;headerlink&quot; title=&quot;代码框&quot;&gt;&lt;/a&gt;代码框&lt;/h2&gt;&lt;p&gt;只需要用两个 反引号把中间的代码包裹起来&lt;/p&gt;
&lt;h2 id=&quot;分割线&quot;&gt;&lt;a href=&quot;#分割线&quot; class=&quot;headerlink&quot; title=&quot;分割线&quot;&gt;&lt;/a&gt;分割线&lt;/h2&gt;&lt;p&gt;分割线的语法只需要另起一行，连续输入三个星号 &lt;em&gt;*&lt;/em&gt; 即可。&lt;/p&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;apos;#&amp;apos;号后加空格，几个#就是几级标题，一共6级标题
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;无序列表&quot;&gt;&lt;a href=&quot;#无序列表&quot; class=&quot;headerlink&quot; title=&quot;无序列表&quot;&gt;&lt;/a&gt;无序列表&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;需要在文字前加上 - 或 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;即可变为无序列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;有序列表&quot;&gt;&lt;a href=&quot;#有序列表&quot; class=&quot;headerlink&quot; title=&quot;有序列表&quot;&gt;&lt;/a&gt;有序列表&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;有序列表则直接在文字前加 1. 2. 3.&lt;/li&gt;
&lt;li&gt;符号要和文字之间加上一个字符的空格。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="small-tool" scheme="http://yoursite.com/categories/small-tool/"/>
    
    
      <category term="makdown" scheme="http://yoursite.com/tags/makdown/"/>
    
  </entry>
  
  <entry>
    <title>gulp自动化构建工具</title>
    <link href="http://yoursite.com/2016/03/07/gulp/"/>
    <id>http://yoursite.com/2016/03/07/gulp/</id>
    <published>2016-03-07T03:51:53.000Z</published>
    <updated>2016-03-14T06:07:15.654Z</updated>
    
    <content type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。&lt;/p&gt;
&lt;h1 id=&quot;gulp能帮我们做什么&quot;&gt;&lt;a href=&quot;#gulp能帮我们做什么&quot; class=&quot;headerlink&quot; title=&quot;gulp能帮我们做什么?&quot;&gt;&lt;/a&gt;gulp能帮我们做什么?&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;javascript语法的检测、合并，压缩。&lt;/li&gt;
&lt;li&gt;css的压缩、合并、sass/less的编译&lt;/li&gt;
&lt;li&gt;images的压缩、合并&lt;/li&gt;
&lt;li&gt;浏览器自动刷新&lt;/li&gt;
&lt;li&gt;部署文件生产替换&lt;/li&gt;
&lt;li&gt;监控文件变化并自动生产相应文件&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;gulp的安装&quot;&gt;&lt;a href=&quot;#gulp的安装&quot; class=&quot;headerlink&quot; title=&quot;gulp的安装&quot;&gt;&lt;/a&gt;gulp的安装&lt;/h1&gt;&lt;p&gt;gulp是基于Nodejs的自动任务运行器，这里默认已经安装了nodejs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全局安装gulp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;npm install --global gulp
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;作为项目的开发依赖安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;npm install --save-dev gulp
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;在项目根目录下创建名为gulpfile.js的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var gulp = require(&amp;apos;gulp&amp;apos;);

gulp.task(&amp;apos;default&amp;apos;, function(){});
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;运行gulp 安装完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;gulp -v

gulp
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;正常安装完成会出现版本号以及执行默认任务&quot;&gt;&lt;a href=&quot;#正常安装完成会出现版本号以及执行默认任务&quot; class=&quot;headerlink&quot; title=&quot;正常安装完成会出现版本号以及执行默认任务&quot;&gt;&lt;/a&gt;正常安装完成会出现版本号以及执行默认任务&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;依赖文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 别忘记在项目的根目录下还应该建相应的资源依赖文件package.json文件，它只是一个普通的json文件(但是不可以写注释)，但是对项目来说，不可或缺，里面不仅存在项目的具体描述信息，还存有项目所需要的包依赖，使用它可以记录相关的gulp插件，以便多人开始时协同使用，另外也可以指令建立：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;gulp原理&quot;&gt;&lt;a href=&quot;#gulp原理&quot; class=&quot;headerlink&quot; title=&quot;gulp原理&quot;&gt;&lt;/a&gt;gulp原理&lt;/h1&gt;&lt;p&gt;  在实现上，glup借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。但是需要注意的是，gulp运行的过程中不会产生临时文件，所有的文件都是虚拟的，直到指定相应目录进行输出。&lt;/p&gt;
&lt;h1 id=&quot;gulp函数&quot;&gt;&lt;a href=&quot;#gulp函数&quot; class=&quot;headerlink&quot; title=&quot;gulp函数&quot;&gt;&lt;/a&gt;gulp函数&lt;/h1&gt;&lt;h2 id=&quot;gulp-src&quot;&gt;&lt;a href=&quot;#gulp-src&quot; class=&quot;headerlink&quot; title=&quot;gulp.src()&quot;&gt;&lt;/a&gt;gulp.src()&lt;/h2&gt;&lt;p&gt;gulp.src()方法输入一个glob(比如匹配一个或多个文件的字符串)或者glob数组，然后返回一个可以传递给插件的数据流。&lt;/p&gt;
&lt;p&gt;Gulp使用node-glob来从你指定的glob里面获取文件,主要匹配规则有以下规则（以js为例）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;js/app.js 精确匹配文件&lt;/li&gt;
&lt;li&gt;js/*.js 仅匹配js目录下的所有后缀为.js的文件&lt;/li&gt;
&lt;li&gt;js/*/.js 匹配js目录及其子目录下所有后缀为.js的文件&lt;/li&gt;
&lt;li&gt;!js/app.js 从匹配结果中排除js/app.js，这种方法在你想要匹配除了特殊文件之外的所有文件时非常管用&lt;/li&gt;
&lt;li&gt;*.+(js|css) 匹配根目录下所有后缀为.js或者.css的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;gulp-task&quot;&gt;&lt;a href=&quot;#gulp-task&quot; class=&quot;headerlink&quot; title=&quot;gulp.task()&quot;&gt;&lt;/a&gt;gulp.task()&lt;/h2&gt;&lt;p&gt;gulp.task()函数通常会被用来定义任务。当你定义一个简单的任务时，需要传入任务名字和执行函数两个属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;greet&amp;apos;, function () {
       console.log(&amp;apos;Hello world!&amp;apos;);
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个任务有时也可以是一系列任务。假设要定义一个任务build来执行css、js、imgs这三个任务，我们可以通过指定一个任务数组而不是函数来完成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;build&amp;apos;, [&amp;apos;css&amp;apos;, &amp;apos;js&amp;apos;, &amp;apos;imgs&amp;apos;]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些任务不是同时进行的，所以你不能认为在js任务开始的时候css任务已经结束了，也可能还没有结束。为了确保一个任务在另一个任务执行前已经结束，可以将函数和任务数组结合起来指定其依赖关系。例如，定义一个css任务，在执行前需要检查greet任务是否已经执行完毕，这样做就是可行的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;css&amp;apos;, [&amp;apos;greet&amp;apos;], function () { });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，当执行css任务时，Gulp会先执行greet任务，然后在它结束后再调用你定义的函数。&lt;/p&gt;
&lt;p&gt;你可以定义一个在gulp开始运行时候默认执行的任务，并将这个任务命名为“default”：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;default&amp;apos;, function () { });
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;gulp-dest&quot;&gt;&lt;a href=&quot;#gulp-dest&quot; class=&quot;headerlink&quot; title=&quot;gulp.dest()&quot;&gt;&lt;/a&gt;gulp.dest()&lt;/h2&gt;&lt;p&gt;gulp.dest()方法是用来写文件的，他将经过gulp处理的文件输出到相应目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var gulp = reruire(&amp;apos;gulp&amp;apos;);
gulp.src(&amp;apos;script/**/*.js&amp;apos;)
    .pipe(gulp.dest(&amp;apos;dist&amp;apos;));
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;gulp-watch&quot;&gt;&lt;a href=&quot;#gulp-watch&quot; class=&quot;headerlink&quot; title=&quot;gulp.watch()&quot;&gt;&lt;/a&gt;gulp.watch()&lt;/h2&gt;&lt;p&gt;gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.watch(glob[, opts], tasks)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gulp可以监听文件的修改动态，然后在文件被改动的时候执行一个或多个任务。这个特性十分有用（对我来说，这可能是Gulp中最有用的一个功能）。你可以保存LESS文件，接着Gulp会自动把它转换为CSS文件并更新浏览器。&lt;/p&gt;
&lt;p&gt;使用gulp.watch()方法可以监听文件，它接受一个glob或者glob数组（和gulp.src()一样）以及一个任务数组来执行回调。&lt;/p&gt;
&lt;p&gt;让我们看看下面，build任务可以将模板转换成html格式，然后我们希望定义一个watch任务来监听模板文件的变化，并将这些模板转换成html格式。watch函数的使用方法如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;watch&amp;apos;, function () {
       gulp.watch(&amp;apos;templates/*.tmpl.html&amp;apos;, [&amp;apos;build&amp;apos;]);
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，当改变一个模板文件时，build任务会被执行并生成HTML文件，也可以给watch函数一个回调函数，而不是一个任务数组。在这个示例中，回调函数有一个包含触发回调函数信息的event对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.watch(&amp;apos;templates/*.tmpl.html&amp;apos;, function (event) {
       console.log(&amp;apos;Event type: &amp;apos; + event.type); // added, changed, or deleted
       console.log(&amp;apos;Event path: &amp;apos; + event.path); // The path of the modified file
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gulp.watch()的另一个非常好的特性是返回我们熟知的watcher。利用watcher来监听额外的事件或者向watch中添加文件。例如，在执行一系列任务和调用一个函数时，你就可以在返回的watcher中添加监听change事件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var watcher = gulp.watch(&amp;apos;templates/*.tmpl.html&amp;apos;, [&amp;apos;build&amp;apos;]);
    watcher.on(&amp;apos;change&amp;apos;, function (event) {
       console.log(&amp;apos;Event type: &amp;apos; + event.type); // added, changed, or deleted
       console.log(&amp;apos;Event path: &amp;apos; + event.path); // The path of the modified file
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了change事件，还可以监听很多其他的事件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;end 在watcher结束时触发（这意味着，在文件改变的时候，任务或者回调不会执行）&lt;/li&gt;
&lt;li&gt;error 在出现error时触发&lt;/li&gt;
&lt;li&gt;ready 在文件被找到并正被监听时触发&lt;/li&gt;
&lt;li&gt;nomatch 在glob没有匹配到任何文件时触发&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Watcher对象也包含了一些可以调用的方法：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;watcher.end() 停止watcher（以便停止执行后面的任务或者回调函数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;watcher.files() 返回watcher监听的文件列表&lt;/li&gt;
&lt;li&gt;watcher.add(glob) 将与指定glob相匹配的文件添加到watcher（也接受可选的回调当第二个参数）&lt;/li&gt;
&lt;li&gt;watcher.remove(filepath) 从watcher中移除个别文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;gulp常用插件&quot;&gt;&lt;a href=&quot;#gulp常用插件&quot; class=&quot;headerlink&quot; title=&quot;gulp常用插件&quot;&gt;&lt;/a&gt;gulp常用插件&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;js语法检测&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var jshint = require(&amp;quot;gulp-jshint&amp;quot;),
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;js压缩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var uglify = require(&amp;quot;gulp-uglify&amp;quot;),
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;css压缩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var minifycss = require(&amp;quot;gulp-minify-css&amp;quot;),
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;sass编译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var sass = require(&amp;quot;gulp-ruby-sass&amp;quot;),
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;图片压缩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var imagemin = require(&amp;quot;gulp-imagemin&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;雪碧图合并&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var spriter = require(&amp;quot;gulp-css-spriter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;js、css的合并&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var concat = require(&amp;quot;gulp-concat&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;文件重命名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var rename = require(&amp;quot;gulp-rename&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;MD5戳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var md5 = require(&amp;quot;gulp-rev&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;路径替换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var collector = require(&amp;quot;gulp-rev-collector&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;刷新浏览器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;var reload = require(&amp;quot;gulp-livereload&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上这些就是gulp常用的插件，至于安装以及其中的用法，这里不做一一介绍，有兴趣的朋友自行研究即可。&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;gulp作为前端的开发的自动化构建工具，确实帮我们完成了很多必要的工作，相对于其他前端构建工具运行速度快，一直为gulp所骄傲，但是同时由于项目的复杂性，以及认为的灵活性，gulp有时也会遇到瓶颈，建议可以参考参考其它构建工具，诸于fis等。&lt;/p&gt;
&lt;p&gt;（gulp的几大函数基本参数是必须掌握的，其中还有一些不常用的参数配置，这里不一一介绍，在项目中进行锻炼时可以慢慢体会）&lt;/p&gt;
&lt;p&gt;下面是gulp的两个参考网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.gulpjs.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp中文网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/blog/tags/528.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp系列教程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。&lt;/p&gt;
&lt;h1 id=&quot;gulp能帮我们做什么&quot;&gt;&lt;a href=&quot;#gulp能帮我们做什么&quot; class=&quot;headerlink&quot; title=&quot;gulp能帮我们做什么?&quot;&gt;&lt;/a&gt;gulp能帮我们做什么?&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;javascript语法的检测、合并，压缩。&lt;/li&gt;
&lt;li&gt;css的压缩、合并、sass/less的编译&lt;/li&gt;
&lt;li&gt;images的压缩、合并&lt;/li&gt;
&lt;li&gt;浏览器自动刷新&lt;/li&gt;
&lt;li&gt;部署文件生产替换&lt;/li&gt;
&lt;li&gt;监控文件变化并自动生产相应文件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="small-tool" scheme="http://yoursite.com/categories/small-tool/"/>
    
    
  </entry>
  
</feed>
